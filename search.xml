<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Hexo从私有仓库部署Github Page</title>
    <url>/2023/07/16/deploy-github-page-from-a-private-repo-by-hexo/</url>
    <content><![CDATA[<p>将博客源文件迁移至私有仓库</p>
<span id="more"></span>
<h2 id="起因">起因</h2>
<p>在开始搭建博客时，为了能够自动部署Github Page，
我参考<a href="https://hexo.io/zh-cn/docs/github-pages">Hexo提供的教程</a>创建了Github Actions进行自动构建。
但这导致源文件也要上传到仓库，然而我并不想把没写完的也传上去，
于是导致没写完的文章积压在本地。</p>
<p>不幸的是之前博客主要是存储在树莓派上，电脑上的是远古版本了。
在毕业后清理了一些在上面写的课程设计，不小心把博客也删掉了。
不过还好
折腾了几次树莓派的备份脚本，<s>虽然折腾完就没用过多少次，幸好期间也没怎么开新的坑</s>，
总算是没有完全丢失草稿。</p>
<p>于是就想着把博客源文件与Github Page仓库分离，把全部文件都上传到私有仓库里。</p>
<h2 id="过程">过程</h2>
<p>其实在之前也想过把仓库变成私有的，但改了之后发现网站没了，去Github Docs看了才知道，
只有付费账户才能使用私有仓库构建Github Page。</p>
<p>但我想保留原有的提交记录，于是我想着把当前存放源文件的分支上传到一个新的仓库，
在Github Page的仓库中创建Actions，让它从我的私有仓库构建。
但转念一想：Github Actions也没法访问我的私有仓库啊，
虽然能通过Personal Token可以做到，
但这玩意也不能放公开仓库用啊。</p>
<p>于是我又想：那我能不能在私有仓库构建好再推送过去。</p>
<p>本着能偷懒就不干活的精神，在搜索了一番后我发现，
Hexo教程中使用到的<code>peaceiris/actions-gh-pages@v3</code>本身就可以完成这个任务
（我还想着找不到就直接配置<code>hexo deploy</code>）。</p>
<p>于是参考<a href="https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-deploy-to-external-repository-external_repository">peaceiris/actions-gh-pages</a>进行了配置。</p>
<h2 id="配置">配置</h2>
<ol>
<li>
<p>在配置中的<code>deploy_key</code>其实就是ssh的私匙，
通过<code>ssh-keygen</code>生成一个就行：</p>
<pre><code class="language-shell">$ ssh-keygen -t rsa -b 4096 -f &quot;hexo-deploy-action-key&quot;
</code></pre>
</li>
<li>
<p>在私有仓库的<code>Settings =&gt; Secrets and variables =&gt; Actions</code>把私匙添加进去，
命个记得住的名（这个要用到的），在这里我用<code>HEXO_DEPLOY_KEY</code>命名。</p>
</li>
<li>
<p>在Github Page仓库中的<code>Settings =&gt; Deploy keys</code>把公匙添加进去。</p>
</li>
<li>
<p>配置<code>actions-gh-pages</code>，参考如下：</p>
<pre><code class="language-yaml"># 前面的省略，与Hexo教程中的一样
- name: Deploy
  uses: peaceiris/actions-gh-pages@v3
  with:
    deploy_key: $&#123;&#123; secrets.HEXO_DEPLOY_KEY &#125;&#125; # 这里的名字填你在步骤2中设置的名字
    external_repository: UserName/username.github.io # 你的Github Page仓库
    publish_branch: master # 在Settings =&gt; Page中设置的构建源分支
    publish_dir: ./public # Hexo _config.yml 中配置的public_dir
    commit_message: &quot;Deploy by Github Actions&quot; # 随意
</code></pre>
</li>
</ol>
<h2 id="完事">完事</h2>
<p>没出错的话，当写完东西并推送到博客的源文件仓库后，就会开始构建。</p>
]]></content>
      <categories>
        <category>事记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>开启评论</title>
    <url>/2023/01/15/comments-are-enabled/</url>
    <content><![CDATA[<h2 id="正式完成主题的评论功能">正式完成主题的评论功能</h2>
<p>嘻嘻</p>
]]></content>
      <tags>
        <tag>Gitalk</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Git提交规范</title>
    <url>/2023/11/02/git-commit-style/</url>
    <content><![CDATA[<p>记录一下我自己的commit注释规范</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>仅仅用于自己的一些比较大的项目，或者说提交量比较多的项目中，
尽可能遵守这里记录的提交风格，<s>不然我自己都看不懂提交了些啥玩意</s>。</p>
<h2 id="博客文章提交">博客文章提交</h2>
<p>基本格式：<code>&lt;type&gt;(type, type): &lt;msg&gt;</code>。其中的<code>type</code>为以下类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">draft</td>
<td style="text-align:left">创建新的草稿</td>
</tr>
<tr>
<td style="text-align:left">post</td>
<td style="text-align:left">创建新文章</td>
</tr>
<tr>
<td style="text-align:left">corr</td>
<td style="text-align:left">文章错误更正</td>
</tr>
<tr>
<td style="text-align:left">theme</td>
<td style="text-align:left">主题更新</td>
</tr>
<tr>
<td style="text-align:left">config</td>
<td style="text-align:left">配置更新</td>
</tr>
<tr>
<td style="text-align:left">update</td>
<td style="text-align:left">文章内容更新</td>
</tr>
<tr>
<td style="text-align:left">others</td>
<td style="text-align:left">其他操作</td>
</tr>
</tbody>
</table>
<p><code>&lt;type&gt;</code>表示此次提交的主要操作，<code>(type)</code>表示此次提交中还进行其他附加操作。
<code>&lt;msg&gt;</code>描述<strong>主要操作</strong>都干了啥，
对于<strong>其他操作</strong>应该有比较详细的描述，
对于<strong>附加操作</strong>可以不说明。</p>
<h2 id="自己项目的代码提交">自己项目的代码提交</h2>
<p>基本格式：<code>&lt;type&gt;: &lt;msg&gt;</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">feat</td>
<td style="text-align:left">新功能实现</td>
</tr>
<tr>
<td style="text-align:left">fix</td>
<td style="text-align:left">缺陷修复</td>
</tr>
<tr>
<td style="text-align:left">typo</td>
<td style="text-align:left">错别字更正</td>
</tr>
<tr>
<td style="text-align:left">revert</td>
<td style="text-align:left">版本回退</td>
</tr>
<tr>
<td style="text-align:left">style</td>
<td style="text-align:left">代码风格变更</td>
</tr>
<tr>
<td style="text-align:left">refact</td>
<td style="text-align:left">代码重构</td>
</tr>
<tr>
<td style="text-align:left">docs</td>
<td style="text-align:left">修改注释</td>
</tr>
<tr>
<td style="text-align:left">merge</td>
<td style="text-align:left">代码合并</td>
</tr>
<tr>
<td style="text-align:left">others</td>
<td style="text-align:left">其他操作</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>在磁盘映像文件上安装 Grub 2</title>
    <url>/2021/08/15/install-grub-at-a-img-file/</url>
    <content><![CDATA[<p>记录一下我在一个磁盘文件上安装Grub作为启动引导的过程</p>
<span id="more"></span>
<h3 id="前言">前言</h3>
<ol>
<li>文中的 Grub 均指 Grub 2，而非 Grub Legacy</li>
<li>文中涉及的安装操作仅限于 Arch Linux，其他发行版请参考 Wiki</li>
<li>分区大小以及文件大小并不一定按照下面所示的设置，但推荐至少 15 M</li>
<li>请在了解执行的命令的作用之后再执行操作</li>
</ol>
<h3 id="使用-dd-创建一个映像文件">使用 dd 创建一个映像文件</h3>
<pre><code class="language-shell">dd if=/dev/zero of=os.img bs=1M count=20
</code></pre>
<p>此命令将在当前目录创建一个大小为 20M，文件名为 os.img 的文件</p>
<h3 id="在-os-img-上创建分区">在 os.img 上创建分区</h3>
<p>此处提供 <code>gdisk</code> 和 <code>fdisk</code> 命令参考</p>
<h4 id="使用-gdisk">使用 gdisk</h4>
<pre><code class="language-shell">gdisk os.img
</code></pre>
<p>进入 gdisk 交互界面<br />
如下所示</p>
<pre><code class="language-shell">GPT fdisk (gdisk) version 1.0.8

Partition table scan:
  MBR: not present
  BSD: not present
  APM: not present
  GPT: not present

Creating new GPT entries in memory.

Command (? for help):
</code></pre>
<blockquote>
<p>根据 <a href="https://wiki.archlinux.org/title/GRUB#BIOS_systems">Arch Linux Wiki</a><br />
需要腾出 1M 空间给 Grub 使用</p>
</blockquote>
<p><strong>创建分区简要步骤：</strong></p>
<ul>
<li>输入 <code>n</code> 创建新的分区</li>
<li>回车选择默认的分区号</li>
<li>再次回车选择默认的起始块</li>
<li>输入 <code>+1M</code> 将分区大小设置为 1M</li>
<li>输入 <code>ef02</code> 将分区类型设置为 Boot 启动分区</li>
<li>输入 <code>n</code> 创建新的分区</li>
<li>之后全部回车，将剩余空间创建为一个分区</li>
<li>输入 <code>p</code> 确认分区无误后，最后输入 <code>w</code> 确认写入文件</li>
</ul>
<p>可能会出现一个警告，确认即可</p>
<p><strong>以下为参考：</strong></p>
<pre><code class="language-shell">GPT fdisk (gdisk) version 1.0.8

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): d
Using 1

Command (? for help): n
Partition number (1-128, default 1):
First sector (34-40926, default = 2048) or &#123;+-&#125;size&#123;KMGTP&#125;:
Last sector (2048-40926, default = 40926) or &#123;+-&#125;size&#123;KMGTP&#125;: +1M
Current type is 8300 (Linux filesystem)
Hex code or GUID (L to show codes, Enter = 8300): ef02
Changed type of partition to 'BIOS boot partition'

Command (? for help): n
Partition number (2-128, default 2):
First sector (34-40926, default = 4096) or &#123;+-&#125;size&#123;KMGTP&#125;:
Last sector (4096-40926, default = 40926) or &#123;+-&#125;size&#123;KMGTP&#125;:
Current type is 8300 (Linux filesystem)
Hex code or GUID (L to show codes, Enter = 8300):
Changed type of partition to 'Linux filesystem'

Command (? for help): p
Disk ./file.img: 40960 sectors, 20.0 MiB
Sector size (logical): 512 bytes
Disk identifier (GUID): 8AECC85A-5E21-48E1-AB62-1684A9A8BF0D
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 40926
Partitions will be aligned on 2048-sector boundaries
Total free space is 2014 sectors (1007.0 KiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            4095   1024.0 KiB  EF02  BIOS boot partition
   2            4096           40926   18.0 MiB    8300  Linux filesystem

Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): Y
OK; writing new GUID partition table (GPT) to ./file.img.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot or after you
run partprobe(8) or kpartx(8)
The operation has completed successfully.
</code></pre>
<h4 id="使用-fdisk">使用 fdisk</h4>
<pre><code class="language-shell">fdisk ./os.img
</code></pre>
<p>进入 fdisk 交互界面</p>
<p>输入 <code>g</code> 新建一个 GPT 分区表</p>
<p>创建分区过程与 <strong>使用gdisk</strong> 一节类似<br />
但创建分区过程无法选择分区类型，需要在创建分区后进行更改</p>
<p>在创建分区后</p>
<ul>
<li>输入 <code>t</code> 更改分区类型</li>
<li>随后会要求选择分区，输入 <code>1</code> 选择第一个分区</li>
<li>然后输入 <code>4</code> 将分区类型更改为 BIOS Boot</li>
</ul>
<p><strong>参考：</strong></p>
<pre><code class="language-shell">命令(输入 m 获取帮助)：t
分区号 (1,2, 默认  2): 1
分区类型或别名（输入 L 列出所有类型）：4

已将分区“Linux filesystem”的类型更改为“BIOS boot”。

命令(输入 m 获取帮助)：
</code></pre>
<p>最后输入 <code>w</code> 确认写入文件</p>
<h3 id="将-os-img-挂载为-loop-设备">将 os.img 挂载为 loop 设备</h3>
<pre><code class="language-shell">$ sudo losetup --show -P -f ./os.img
/dev/loop0
</code></pre>
<p>命令解释：</p>
<ul>
<li><code>--show</code> 在挂载成功后，显示挂载的设备名</li>
<li><code>-P</code> 创建带分区的 loop 设备</li>
<li><code>-f</code> 查找第一个未使用的设备</li>
</ul>
<p>显示的设备名不一定是 <code>/dev/loop0</code><br />
在后文出现的 <code>/dev/loop0</code> 更改为你实际操作时显示的名称</p>
<h3 id="格式化并挂载分区">格式化并挂载分区</h3>
<blockquote>
<p>在文中实例中，需要格式化的是第二个分区<br />
对应的 loop 设备为 <code>/dev/loop0p2</code><br />
如上一个步骤中的显示的 loop 设备不同，请自行更改</p>
</blockquote>
<pre><code class="language-shell">sudo mkfs.vfat -n &quot;BOOT&quot; /dev/loop0p2
</code></pre>
<p>不出意外的话，格式化很快就能完成<br />
随后挂载分区</p>
<p>请选择一个没有正在使用的文件夹<br />
在本文中选择 <code>/mnt</code> 作为挂载点<br />
这个文件夹在之后会使用到</p>
<pre><code class="language-shell">sudo mount /dev/loop0p2 /mnt
</code></pre>
<p>没有消息就是最好的消息</p>
<h3 id="安装-Grub">安装 Grub</h3>
<blockquote>
<p>下面的操作在执行命令前一定要确认
误操作可能会影响本机的 <code>/boot</code> 分区</p>
</blockquote>
<p>此处示例将安装以 <strong>BIOS 方式启动</strong>的<strong>i386 平台</strong>的 Grub<br />
使用上一个步骤的挂载点 <code>/mnt</code> 作为安装目录</p>
<pre><code class="language-shell">sudo grub-install --target=i386-pc --boot-directory=/mnt/boot /dev/loop0
</code></pre>
<p>命令解释：</p>
<ul>
<li><code>target=i386-pc</code> 指出安装架构为 i386</li>
<li><code>boot-directory=/mnt/boot</code> 指出安装到 <code>/mnt/boot</code> 而不是默认的 <code>/boot</code></li>
</ul>
<p>安装需要 13M 左右的空间<br />
完成后会提示成功</p>
<h3 id="配置">配置</h3>
<p>照着手册随便糊的一个，<s>能用就行</s></p>
<pre><code class="language-shell"># Grub 的配置文件

# 设置根分区
set root='(hd0,gpt2)'

# 选择启动项超时时间，0 即立即启动
set timeout=0

# 菜单选项
menuentry EntryName &#123;
    # 载入 file 并启动
    multiboot ($root)/boot/file
    boot
&#125;
</code></pre>
<h3 id="卸载设备">卸载设备</h3>
<pre><code class="language-shell">sudo umount /mnt
sudo losetup -d /dev/loop0
</code></pre>
<p>上面的命令将从挂载点卸载 loop 设备<br />
并释放 loop 设备与文件的关联</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="https://www.gnu.org/software/grub/manual/grub/grub.html">Grub 手册</a></li>
</ul>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Grub</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降算法</title>
    <url>/2021/09/16/gradient-descent/</url>
    <content><![CDATA[<p>介绍 <strong>梯度下降算法 (gradient descent algorithm)</strong> 并简单解释其原理</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<ol>
<li>随机选取一个初始位置$ x_{0} $。</li>
<li>对$ x_{0} $进行更新，即：
$$
x_{1} = x_{0} - \alpha \frac{\mathrm d}{\mathrm dx}f(x_{0})
$$
其中$ \alpha $是一个正数，称作 “步长”，
$ \frac{\mathrm d}{\mathrm dx}f(x*{0}) $是$ f(x) $在$ x*{0} $处的导数。</li>
<li>重复进行 <code>步骤2</code> 中的更新操作，最终得到$ x*{n} $使得$ f(x*{n}) $最小。</li>
</ol>
<h2 id="数学原理简析">数学原理简析</h2>
<h3 id="基本原理">基本原理</h3>
<p>设函数$ f(x) $为二次函数，且在$ x = x*{min} $处取得最小值，
且设在点$ x*{n} $处的导数$ \frac{\mathrm d}{\mathrm dx}f(x*{n}) = k*{n} $
随机选取一点$ x_{0} $：</p>
<ol>
<li>
<p>若$ k*{0} &lt; 0 $，则$ x*{0} &lt; x*{min} $，
令$ x*{1} = x*{0} - k*{0} $，则$ x*{1} &lt; x*{0} $，
即$ x*{1} $向$ x*{min} $靠近。</p>
</li>
<li>
<p>若$ k*{0} &gt; 0 $，则$ x*{0} &gt; x*{min} $，
令$ x*{1} = x*{0} - k*{0} $，则$ x*{1} &gt; x*{0} $，
即$ x*{1} $向$ x*{min} $靠近。</p>
</li>
</ol>
<p>可知，更新后的$ x*{n} $一定从$ x*{n - 1} $向$ x_{min} $的方向移动。</p>
<h3 id="使用条件">使用条件</h3>
<p>在基本原理中可以发现，获得$ x_{n} $的过程不依赖于原函数，
只需要知道原函数的一阶导函数。
因此，在原函数为二次函数且存在最小值，导函数比原函数更容易获得时，
可以考虑采取梯度下降算法。</p>
<h3 id="不足之处">不足之处</h3>
<p>设$ f(x) = x^{2} $，
函数在$ x*{min} = 0 $处取得最小值，可知
$ k*{n} = \frac{\mathrm d}{\mathrm dx}f(x*{n}) = 2n $。
取初始值$ x*{0} = 1 $，则$ x*{1} = x*{0} - k*{0} = -1 $。
继续对$ x*{1} $进行更新，则$ x*{2} = x*{1} - k*{1} = 1 = x*{0} $。
这导致无论如何更新，最终结果都只是$ x = 1 $和$ x = -1 $两个值，永远无法得到$ x_{min} = 0 $。</p>
<p>此外，在复杂的函数中，梯度下降算法只能得到局部最优解。</p>
<h3 id="改进">改进</h3>
<p>因此，需要引入$ \alpha $控制$ x $变化的幅度，
$ \alpha $的值越小，需要进行递减的次数越多，这才能保证得出的结果接近最小值$ x_{min} $。
一般来说，$ \alpha $是一个小于 1 但大于 0 的值，具体的值需要根据实际情况进行调整。</p>
<h2 id="代码示例">代码示例</h2>
<p>设函数为$ f(x) = 3x^{2} + 4x + 5 $，
则$ \frac{\mathrm d}{\mathrm dx} f(x) = 6x + 4 $，
最低点为$ x_{min} = - \frac{B}{2A} = - \frac{2}{3} $。</p>
<pre><code class="language-python">#!/usr/bin/env python3

import numpy as np

a = 3
b = 4
c = 5

# f(x) = ax^2 + bx + c
def f(x):
    return a*(x**2) + b*x + c

# df(x) = 2ax + b
def df(x):
    return 2*a*x + b

def main():
    # 最低点
    xmin = - b/(2*a)
    # 步长
    alpha = 0.1
    # 随机初始值
    x = np.random.randint(5)
    # 递减 100 次
    for i in range(100):
        x = x - alpha * df(x)

    # 输出结果
    print(&quot;x_n is:&quot; , x)
    print(&quot;x_min is:&quot;, xmin)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Intel x86 汇编语言</title>
    <url>/2021/03/26/intel-asm/</url>
    <content><![CDATA[<p>文章参考自<a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86 Assembly Guide</a>
这篇文章只是个人的理解翻译，方便日后参考使用<br />
详情请参见原文</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>学习计算机组成原理有助于理解本文：</p>
<p>一些资源：</p>
<ul>
<li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/vsasm.html">在 Visual Studio 使用汇编</a></li>
<li><a href="http://www.felixcloutier.com/x86/">Intel x86 汇编指令集参考</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel Pentium 手册</a></li>
</ul>
<h2 id="寄存器">寄存器</h2>
<p>现代 x86 处理器中，有 8 个通用寄存器，在历史上，它们按照不同的用途命名<br />
如 <code>EAX</code> 叫做“累加器”，因为它常被用作加法计算<br />
在现代，尽管它们并没有什么区别，但习惯上仍沿用历史的做法<br />
对于 32 位的 <code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code><br />
我们也可以单独访问它们的低 16 位或者更低的位数<br />
如 <code>EAX</code> ，通过</p>
<ul>
<li><code>AX</code> 可访问低 16 位(0~15)</li>
<li><code>AH</code> 可访问低 16 位中的高 8 位(8~15)</li>
<li><code>AL</code> 可访问低 16 中的低 8 位(0~7)</li>
</ul>
<p><strong>E</strong> 是 <strong>Extended</strong>，即 <strong>拓展</strong> 的意思<br />
说明 <code>EAX</code>(32位) 是 <code>AX</code>(16位) 的拓展</p>
<p><strong>X</strong> 其实也是 <strong>拓展</strong> 的意思<br />
但它是指从 <code>AL</code>(8位) 拓展到 <code>AX</code>(16位)</p>
<h3 id="通用寄存器">通用寄存器</h3>
<ul>
<li><code>EAX</code>(accumulator): 累加寄存器</li>
<li><code>EBX</code>(base): 基址寄存器</li>
<li><code>ECX</code>(counter): 计数寄存器</li>
<li><code>EDX</code>(data): 数据寄存器</li>
<li><code>ESI</code>(source index): 源变址寄存器</li>
<li><code>EDI</code>(destination index): 目的变址寄存器</li>
<li><code>ESP</code>(stack pointer): 栈指针寄存器</li>
<li><code>EBP</code>(base pointer): 基址指针寄存器</li>
</ul>
<h3 id="段寄存器">段寄存器</h3>
<ul>
<li><code>CS</code> (code segment): 代码段寄存器</li>
<li><code>SS</code> (stack segment): 栈寄存器</li>
<li><code>DS</code> (data segment): 数据段寄存器</li>
<li><code>ES</code>, <code>FS</code>, <code>GS</code>: 同 <code>DS</code></li>
</ul>
<h3 id="标志寄存器与指令寄存器">标志寄存器与指令寄存器</h3>
<ul>
<li><code>EFLAGS</code>: 标志寄存器</li>
<li><code>EIP</code> (instruction pointer): 指令寄存器</li>
</ul>
<h2 id="内存与寻址模式">内存与寻址模式</h2>
<p>寻址模式可分为：
直接寻找、间接寻址、变址寻址</p>
<p><strong>直接寻址</strong>：给出的地址是存放的是 <strong>数据</strong><br />
<strong>间接寻址</strong>：给出的地址是存放的是 <strong>数据的地址</strong><br />
<strong>变址寻址</strong>：给出的地址作为基准，使用偏移得到数据的真实地址，进而得到数据</p>
<h3 id="内存寻址">内存寻址</h3>
<p>使用 <code>[]</code> 表示进行寻址<br />
即: 如 <code>[eax]</code> 指的是将 <code>eax</code> 中存储的数据作为内存地址<br />
随后读取该内存地址中存储的数据，这属于寄存器间接寻址</p>
<p>现在简单介绍 <code>mov</code> 指令，并使用它在寄存器与内存间传递数据<br />
<code>mov</code> 指令有两个参数，第一个参数为目的地，第二个是数据源</p>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
mov     eax, [ebx]              ; 将 EBX 中存储的数据作为内存地址
                                ; 将内存地址中的数据存入EAX

mov     [var], ebx              ; 将 var 中存储的数据作为内存地址
                                ; 将 EBX 中的数据存入内存地址

mov     eax, [esi - 4]          ; 将 ESI 中存储的数据加上 -4 作为内存地址
                                ; 将内存地址中的数据存入EAX

mov     [esi + eax], cl         ; 将 ESI 与 EAX 中的数据相加作为内存地址
                                ; 将 CL 中存储的数据存入内存地址

mov     edx, [esi + 4 * ebx]    ; 将 ESI 中存储的数据加上 EBX 中的数据 * 4 作为内存地址
                                ; 将内存地址中的数据存入EDX
</code></pre>
<p>注意，以下语法是 <strong><em>错误的</em></strong></p>
<pre><code class="language-asm">
mov     eax, [ebx - ecx]            ; 寄存器间只能相加
mov     [eax + esi + edi], ebx      ; 最多只能有两个寄存器相加
</code></pre>
<h2 id="声明静态数据区域与数据">声明静态数据区域与数据</h2>
<p>使用 <code>.DATA</code> 声明一块数据区域，并在此区域声明静态数据</p>
<h3 id="声明数据">声明数据</h3>
<p>数据可以被给予一个“名字”，如 “var”，这个“名字”代表的其实是此数据在内存中的地址
<code>DB</code>(declare byte)可以声明 1 字节的数据
<code>DW</code>(declare word)可以声明 2 字节的数据
<code>DD</code>(declare dobute word)可以声明 4 字节的数据</p>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
.DATA
    var     DB  64      ; 声明一个 1 字节，名为 var，值为 64 的数据
    var2    DB  ?       ; 声明一个 1 字节，名为 var2，值未初始化的数据
            DB  10      ; 声明一个 1 字节，没有名字，使用 [var2 + 1] 访问，值为 10 的数据
    X       DW  ?       ; 声明一个 2 字节，名为 X，值未初始化的数据
    Y       DD  30000   ; 声明一个 2 字节，名为 Y，值为 30000 的数据
</code></pre>
<h3 id="指定数据大小">指定数据大小</h3>
<p>通常来说，数据大小能从给出的寄存器判断得出，例如 <code>AX</code> 即指 16 位数据，也就是 2 字节<br />
但在一些情况下无法判断数据大小，如 <code>mov  [eax], 2</code>, 这种情况下不能明确知道数据的大小<br />
因此需要在指令中指定数据大小，使用方法如下：<br />
<code>BYTE PTR</code> 指定 1 字节大小<br />
<code>WORD PTR</code> 指定 2 字节大小<br />
<code>DWORD PTR</code> 指定 4 字节大小</p>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
mov     BYTE PTR    [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 1 字节
mov     WORD PTR    [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 2 字节
mov     DWORD PTR   [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 4 字节
</code></pre>
<h3 id="声明数组">声明数组</h3>
<p>不像高级编程语言，汇编语言不能按照 <em>下标</em> 对数组进行索引，只能通过 <em>偏移</em> 的方式定位数据<br />
在汇编中，数组内的所有数据在一块连续的区域，可通过 <em>基址寻址</em> 的方式寻找数据<br />
数组可以通过 <em>列出连续的数据</em> 来声明，或者通过 <code>DUP</code> 指令 <em>创建连续的数据</em> 进行声明<br />
<code>DUP</code> 指令告诉汇编器以指定的次数重复地列出一个数据，例如 <code>3 DUP(2)</code> 意味着 <code>2, 2, 2</code></p>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
.DATA
    Z       DD  1, 2, 3     ; 声明一个具有 3 个 4 字节元素，名为 Z 的数组
                            ; 值分别为 1, 2 和 3，位于 Z + 8 地址上的值是 3

    bytes   DB  10  DUP(?)  ; 声明一个具有 10 个 1 字节元素，名为 bytes 的数组，值未初始化

    arr     DD  100 DUP(0)  ; 声明一个具有 100 个 4 字节元素，名为 arr 的数组，值初始化为 0

    str     DB  'hello',0   ; 声明一个具有 6 个 1 字节元素，名为 arr 的数组
                            ; 值初始化为 'hello' 的 ASCII 字符编码，以及 0
</code></pre>
<h2 id="指令">指令</h2>
<p>指令一般由操作码与操作数组成，其中操作数可以有多个，也有部分指令没有操作数<br />
指令可分为：数据转移指令、算术运算与逻辑指令、流程控制指令三类<br />
约定在下文中，使用特定的格式表述不同位数的寄存器、数据、以及内存等<br />
约定如下：<br />
<code>&lt;reg32&gt;</code> 32位寄存器，如 <code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code>、<code>EDI</code>、<code>EBP</code><br />
<code>&lt;reg16&gt;</code> 16位寄存器，如 <code>AX</code>、<code>BX</code>、<code>CX</code>、<code>DX</code><br />
<code>&lt;reg8&gt;</code> 8位寄存器。如 <code>AH</code>、<code>AL</code>、<code>BH</code>、<code>BL</code>、<code>CH</code>、<code>CL</code>、<code>DH</code>、<code>DL</code><br />
<code>&lt;mem&gt;</code> 内存，如 <code>[eax]</code>、<code>[var + 4]</code><br />
<code>&lt;con32&gt;</code> 32位常量（4 字节）<br />
<code>&lt;con16&gt;</code> 32位常量（2 字节）<br />
<code>&lt;con8&gt;</code> 32位常量（1 字节）<br />
<code>&lt;con&gt;</code> 任意位数常量</p>
<h3 id="数据转移指令">数据转移指令</h3>
<h4 id="mov-指令"><code>mov</code> 指令</h4>
<p>Move (操作码：88, 89, 8A, 8B, 8C, 8E, …)<br />
<code>mov</code> 指令将它第二个操作数声明的数据复制到第一个操作数指定的位置<br />
这个位置可以是内存或者寄存器</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
mov     &lt;reg&gt;, &lt;reg&gt;
mov     &lt;reg&gt;, &lt;mem&gt;
mov     &lt;mem&gt;, &lt;reg&gt;
mov     &lt;reg&gt;, &lt;con&gt;
mov     &lt;mem&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
mov     eax, ebx                ; 将 ebx 中的数据复制到 eax
mov     byte ptr    [var], 5    ; 将 5 赋值给名为 var 的变量
</code></pre>
<h4 id="push-指令"><code>push</code> 指令</h4>
<p>压入栈 Push stack (操作码：FF, 89, 8A, 8B, 8C, 8E, …)<br />
<code>push</code> 指令将它的操作数压入栈堆，存储在特定的寄存器中（一般是存储在 <code>ESP</code>）<br />
<code>push</code> 首先将 <code>ESP</code> 中的数据减去 4，随后将操作数存储到 <code>ESP</code> 指向的内存地址中<br />
注：栈里的数据存储在内存中，寄存器 <code>ESP</code> 存储的是内存地址，栈在内存中从高地址向低地址增长</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
push    &lt;reg32&gt;
push    &lt;mem&gt;
push    &lt;con32&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
push    eax     ; 将 EAX 中的数据压入栈
push    [var]   ; 将名为 var 的变量的值压入栈
</code></pre>
<h4 id="pop-指令"><code>pop</code> 指令</h4>
<p>弹出栈 Pop stack<br />
<code>pop</code> 指令将特定寄存器的值（一般是 <code>ESP</code>）弹出，存储到它的操作数指定的位置<br />
<code>pop</code> 首先读取位于由 <code>ESP</code> 给出的内存地址中的值，将其存入到操作数指定的位置<br />
随后将 <code>ESP</code> 的值加 4</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
pop     &lt;reg32&gt;
pop     &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
pop     edi     ; 将栈顶数据弹出，存储到 EDI
pop     [ebx]   ; 将栈顶数据弹出，存储到由 EBX 给出的内存地址中
</code></pre>
<h4 id="lea-指令"><code>lea</code> 指令</h4>
<p>取地址 load effective address<br />
<code>lea</code> 指令将第二操作数的有效地址存入第一个操作数给定的寄存器中<br />
<code>lea</code> 与 <code>mov</code> 并不同，<code>mov</code> 是将第二操作数给定的数据存入第一操作数给定的位置<br />
而 <code>lea</code> 是将数据的地址存入第一操作数给定的寄存器</p>
<p><strong>语法：</strong></p>
<pre><code class="language-asm">
lea     &lt;reg32&gt;, &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
lea     edi, [ebx + 4*esi]      ; EBX + 4*ESI 的值作为地址存入 EDI
lea     eax, [var]              ; var 代表的地址存入 EAX
</code></pre>
<h3 id="算术运算与逻辑指令">算术运算与逻辑指令</h3>
<h4 id="add-指令"><code>add</code> 指令</h4>
<p><code>add</code> 指令将它的两个操作数的值相加，并将结果存储到第一个操作数指定的位置中<br />
注意，操作数可以是两个寄存器，但最多只能有一个是内存地址</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
add     &lt;reg&gt;, &lt;reg&gt;
add     &lt;reg&gt;, &lt;mem&gt;
add     &lt;mem&gt;, &lt;reg&gt;
add     &lt;reg&gt;, &lt;con&gt;
add     &lt;mem&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
add     eax, 10                     ; eax = eax + 10
add     byte ptr [var], 10          ; var = var + 10
</code></pre>
<h4 id="sub-指令"><code>sub</code> 指令</h4>
<p>与 <code>add</code> 指令相似，<code>sub</code> 指令将第一个操作数的值减去第二个操作数，结果保存在第一个操作数</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
sub     &lt;reg&gt;, &lt;reg&gt;
sub     &lt;reg&gt;, &lt;mem&gt;
sub     &lt;mem&gt;, &lt;reg&gt;
sub     &lt;reg&gt;, &lt;con&gt;
sub     &lt;mem&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
sub     al, ah      ; AL = AL - AH
sub     eax, 216    ; 将 EAX 中的值减去 216，结果保存在 EAX
</code></pre>
<h4 id="inc-与-dec-指令"><code>inc</code> 与 <code>dec</code> 指令</h4>
<p><code>inc</code> 指令将操作数的值增加 1 （自增）
<code>dec</code> 指令将操作数的值减少 1 （自减）</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
inc     &lt;reg&gt;
inc     &lt;mem&gt;
dec     &lt;reg&gt;
dec     &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
inc     eax                 ; 将 EAX 中的值自增 1，结果存入 EAX
dec     DWORD PTR   [var]   ; 将 var 中的 32 位的值自减 1，结果存入 var （代表的地址）
</code></pre>
<h4 id="imul-指令"><code>imul</code> 指令</h4>
<p>整数相乘 Integer Multiplication<br />
<code>imul</code> 指令有两种基本的格式，分别为 <em>带 2 个操作数</em>、<em>带 3 个操作数</em></p>
<ul>
<li>带 2 个操作数时，将两个操作数相乘，结果存入第一个操作数处</li>
<li>带 3 个操作数时，将第 3 个和第 2 个操作数相乘，结果存入第一个操作数处</li>
</ul>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
imul    &lt;reg32&gt;, &lt;reg32&gt;
imul    &lt;reg32&gt;, &lt;mem&gt;
imul    &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;
imul    &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
imul    eax, [var]      ; 将 var 的值与 EAX 的值相乘，结果存入 EAX
imul    esi, edi, 25    ; 将 EDI 的值与 25 相乘，结果存入 ESI
</code></pre>
<h4 id="idiv-指令"><code>idiv</code> 指令</h4>
<p><code>idiv</code> 指令将给出的操作数除以存储在 EDX:EAX 的 64 位的整数<br />
EDX 中的值作为高四位，EAX 中的值作为低四位<br />
得到的商存储在 EAX 中，余数存储在 EDX 中</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
idiv    &lt;reg32&gt;
idiv    &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
idiv    ebx                 ; 将 EBX 中的值除以 EDX:EAX，商存在 EAX，余数存在 EDX
idiv    DWORD PTR [var]     ; 将存在 var 表示内存地址中的 32 位的值除以 EDX:EAX，商存在 EAX，余数存在 EDX
</code></pre>
<h4 id="and-or-xor-指令"><code>and</code> <code>or</code> <code>xor</code> 指令</h4>
<p>这些指令分别是将两个操作数进行<em>按位与</em>，<em>按位或</em>，<em>按位异或</em>操作<br />
得到的结果存在第一个操作数</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
and     &lt;reg&gt;, &lt;reg&gt;
and     &lt;reg&gt;, &lt;mem&gt;
and     &lt;mem&gt;, &lt;reg&gt;
and     &lt;reg&gt;, &lt;con&gt;
and     &lt;mem&gt;, &lt;con&gt;

or      &lt;reg&gt;, &lt;reg&gt;
or      &lt;reg&gt;, &lt;mem&gt;
or      &lt;mem&gt;, &lt;reg&gt;
or      &lt;reg&gt;, &lt;con&gt;
or      &lt;mem&gt;, &lt;con&gt;

xor     &lt;reg&gt;, &lt;reg&gt;
xor     &lt;reg&gt;, &lt;mem&gt;
xor     &lt;mem&gt;, &lt;reg&gt;
xor     &lt;reg&gt;, &lt;con&gt;
xor     &lt;mem&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
and     EAX, 0fH    ; 只保留 EAX 的低 4 位
xor     EDX, EDX    ; 将 EDX 所有位置 0
</code></pre>
<h4 id="not-指令"><code>not</code> 指令</h4>
<p>进行按位取反操作</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
not     &lt;reg&gt;
not     &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
not     BYTE PTR [var]      ; 将 var 地址处的值按位取反
</code></pre>
<h4 id="neg-指令"><code>neg</code> 指令</h4>
<p>对操作数内容的二进制补码进行按位取反操作</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
neg     &lt;reg&gt;
neg     &lt;mem&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
neg     EAX         ; 将得到 -EAX
</code></pre>
<h4 id="shl-shr-指令"><code>shl</code> <code>shr</code> 指令</h4>
<p>左移右移指令<br />
将第一个操作数进行左移或者右移，用 0 填充空位，最多移动 31 位<br />
移动的位数由第二个操作数决定，第二个操作数可以是 8 位常量或者是 CL 寄存器<br />
若移动位数大于 31，则按照以 32 为模得出的值进行移位</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
shl     &lt;reg&gt;,&lt;con8&gt;
shl     &lt;mem&gt;,&lt;con8&gt;
shl     &lt;reg&gt;, CL
shl     &lt;mem&gt;, CL

shr     &lt;reg&gt;,&lt;con8&gt;
shr     &lt;mem&gt;,&lt;con8&gt;
shr     &lt;reg&gt;, CL
shr     &lt;mem&gt;, CL
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
shl     EAX, 1          ; 将 EAX 乘以 2
shr     EBX, CL         ; 将 EBX 除以 2n, 其中 n 是 CL 的值
</code></pre>
<h3 id="流程控制">流程控制</h3>
<p>x86 处理器有一个指令寄存器 (instruction pointer register)(IP)<br />
这是一个 32 位的寄存器，保存当前执行的指令在内存中的起始地址<br />
通常来说，它每执行一个指令后会自增，以指向下一个指令的起始地址<br />
指令寄存器不能被直接更改 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但可以通过流程控制指令进行更新</p>
<p>在这里约定一个新的符号 <code>&lt;lable&gt;</code>，它用来表示汇编代码中的一个标签<br />
如，在下面的代码中：</p>
<pre><code class="language-asm">
        mov     ESI, [EBP + 8]
begin:  xor     ECX, ECX
        mov     EAX, [ESI]
</code></pre>
<p><code>begin</code> 是一个 <code>&lt;lable&gt;</code><br />
实际上这个标签是一个代表地址的符号，与变量 <code>var</code> 类似<br />
但标签代表的是指令的地址，而变量代表的是数据的地址<br />
可以在代码的其他位置使用这个标签来获得标签表示的地址</p>
<p>在下面的示例中并不会特别指出 <code>&lt;lable&gt;</code> 所代表的指令<br />
只说明各跳转指令的用法</p>
<h4 id="jmp-指令"><code>jmp</code> 指令</h4>
<p>无条件跳转指令<br />
无条件地将程序控制流跳转到操作数指示的位置处</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
jmp     &lt;lable&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
jmp     begin       ; 跳转到 begin 处
</code></pre>
<h4 id="条件跳转指令">条件跳转指令</h4>
<p>这是一个统称，代表着一系列根据不同条件判断是否进行跳转的指令<br />
如果符合条件，则会执行跳转，否则将按原来的流程继续执行下一条指令</p>
<p>条件跳转指令的条件来自最后执行算术运算的信息，如：结果是否为零<br />
这些信息保存在一个特殊的寄存器中，称作状态寄存器 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> (machine status word)</p>
<p>许多指令的转移条件可以根据上一次执行的操作直观地得出<br />
这个操作指的是特殊的比较指令 <code>cmp</code> （在下文有说明）<br />
例如：<code>jle</code> 和 <code>jne</code> 依赖于 <code>cmp</code> 指令对操作数的执行结果<br />
因此，条件转移指令通常会和 <code>cmp</code> 指令一起使用</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
je      &lt;lable&gt;     ; 相等时跳转
jne     &lt;lable&gt;     ; 不相等时跳转
jz      &lt;lable&gt;     ; 结果为 0 时跳转
jg      &lt;lable&gt;     ; 大于时跳转
jge     &lt;lable&gt;     ; 大于或等于时跳转
jl      &lt;lable&gt;     ; 小于是跳转
jle     &lt;lable&gt;     ; 小于或等于时跳转
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
cmp     EAX, EBX
jle     done        ; 如果 EAX 小于或者等于 EBX，则跳转至 done 处
mov     EAX, EBX    ; 否则继续执行下一条指令，也就是这一行的指令
</code></pre>
<h4 id="cmp-指令"><code>cmp</code> 指令</h4>
<p>将给出的两个操作数进行对比，并更新状态寄存器<br />
<code>cmp</code> 指令等效于 <code>sub</code> 指令，唯一区别则在于<br />
<code>cmp</code> 指令会将结果丢弃而不是存入第一个操作数</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
cmp     &lt;reg&gt;, &lt;reg&gt;
cmp     &lt;reg&gt;, &lt;mem&gt;
cmp     &lt;mem&gt;, &lt;reg&gt;
cmp     &lt;reg&gt;, &lt;con&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
cmp     DWORD PTR [var], 10
jeq     loop
; 如果 var 的值等于 10，则会跳转到 loop
; 否则执行下一条指令
</code></pre>
<h4 id="call-ret-指令"><code>call</code> <code>ret</code> 指令</h4>
<p>这两个指令实现了子程序的调用与返回<br />
<code>call</code> 指令会先将当前代码的位置压入堆栈，然后无条件跳转到标签处<br />
与简单的 <code>jmp</code> 指令不同，<code>call</code> 指令会保存子程序完成时应返回的位置</p>
<p><code>ret</code> 实现从子程序中的返回<br />
它首先将在堆栈中的地址弹出，然后无条件跳转到此地址<br />
子程序返回后则继续执行下一条指令</p>
<p><strong>用法：</strong></p>
<pre><code class="language-asm">
; call 用法
call    &lt;lable&gt;

; ret 用法
ret
</code></pre>
<p><strong>例子：</strong></p>
<pre><code class="language-asm">
callme: xor     EAX, EAX
        ret                 ; 返回到调用处
call    callme              ; 调用 callme
        xor     EBX, EBX    ; 返回后继续执行指令
</code></pre>
<h2 id="调用约定">调用约定</h2>
<p>调用约定是为了使程序员之间能够共享代码并开发可以供许多程序使用的库，并简化子程序的使用<br />
是一组约定如何调用以及如何返回的协议<br />
在给定规则的情况下，程序员无需了解子程序的定义，只需按照约定进行调用即可<br />
并且，可以使高级语言的汇编器遵从约定，使得手工编写的汇编代码能够调用高级语言编写的函数</p>
<p>最为广泛使用的是 C 语言的调用约定<br />
遵从这个约定，我们可以调用定义在 C 或者 C++ 程序里的函数<br />
并且还能够调用 C 的库函数</p>
<p>C 调用约定很大程度上基于硬件支持堆栈的使用<br />
它基于 <code>push</code>、<code>pop</code>、<code>call</code> 和 <code>ret</code> 指令，子程序参数在堆栈上传递<br />
寄存器保存在栈上，子程序使用的局部变量放在栈上的内存中<br />
在大多数处理器上实现的绝大多数高级过程语言使用都使用类似的调用约定</p>
<p>调用约定分为两组，一组规则由调用者使用，另一组由被调用者<br />
注意：<br />
在调用期间发生的错误会导致严重的程序错误，因为这会使堆栈处于不确定的状态</p>
<p>示意图：</p>
<pre><code class="language-shell">      栈增长方向
+------------------+
| saved ESI        | &lt;--- ESP
+------------------+
| saved EDI        |
+------------------+
| local variable 3 |
+------------------+
| local variable 2 |
+------------------+
| local variable 1 | &lt;--- EBP - 4
+------------------+
| saved EBP        | &lt;--- EBP
+------------------+
| return address   |
+------------------+
| parameter 1      | &lt;--- EBP + 8
+------------------+
| parameter 2      | &lt;--- EBP + 12
+------------------+
| parameter 3      | &lt;--- EBP + 16
+------------------+
      高地址方向
</code></pre>
<p>在上面的示意图中，调用者向子程序传递了 3 个参数 <code>parameter 1 - 3</code><br />
子程序有三个自己的局部变量 <code>local variable 1 - 3</code><br />
堆栈中每个单元是 32 位宽的内存位置，故相邻的单元格相隔 4 个字节<br />
传入子程序的第一个参数位置在 EBP 偏移 8 个字节的偏移处<br />
在传入参数的上方与基指针（图中EBP）的下方是返回地址<br />
当使用 <code>ret</code> 指令从子程序返回时，会跳转至这个返回地址</p>
<h3 id="调用方规则">调用方规则</h3>
<p>为了进行调用，调用方应该：</p>
<ol>
<li>调用前，调用方应该保存 EAX, ECX, EDX 这些<em>调用方保存寄存器</em> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 的值<br />
因为子程序能够更改这些寄存器的值<br />
如果调用方需要在子程序返回后继续使用这些值，那么调用方必须将这些值压入栈<br />
以便在子程序返回后恢复这些值</li>
<li>在调用前将参数压入栈，以传递给子程序使用<br />
应以相反的顺序将参数压入栈，如：最后一个参数应第一个压入栈<br />
因为栈遵从先进后出原则，所以第一个参数处于低地址处 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><br />
这种参数倒置的方式在历史上被用于允许函数传递可变数量的参数</li>
<li>使用 <code>call</code> 指令调用子程序<br />
这个指令会先将返回的地址压入堆栈，然后切换到子程序执行指令</li>
</ol>
<p>在子程序返回后，调用方能从 EAX 寄存器中获得子程序的返回值<br />
为了将程序恢复到调用前的状态，调用方此时应该：</p>
<ol>
<li>从栈中移除传递的参数，将栈恢复到调用前的状态</li>
<li>将存储在栈中的寄存器（EAX, ECX, EDX）的值弹出，以恢复这些寄存器在调用前的值<br />
调用方可以假设没有其他寄存器被子程序修改</li>
</ol>
<p><strong>例子：</strong>
下面的代码是一个简单的调用方的示例<br />
调用方调用了一个名为 <em>_myFunc</em> 的函数，这个函数需要传递三个整数型参数：</p>
<ul>
<li>第一个参数存储在 EAX 寄存器</li>
<li>第二个参数是常量 216</li>
<li>第三个参数是存储在内存地址 <em>var</em> 中的值</li>
</ul>
<pre><code class="language-asm">
push    [var]           ; 传递第三个参数
push    216             ; 传递第二个参数
push    EAX             ; 传递第一个参数

call    _myFunc         ; 调用子程序

add     ESP, 12         ; 清理传入的参数
</code></pre>
<blockquote>
<p>注意：从子程序返回后，EBP 的值也恢复到了 <em>saved EBP</em> （见上方的示意图）表示的值<br />
ESP 则指向 <em>return address</em> 处</p>
</blockquote>
<p>在代码的最后，使用了 <code>add</code> 指令修改了 ESP 的值，这是为了清理传入的参数<br />
在上面提到，一个单元格为 32 位，即 4 字节<br />
我们传入了 3 个参数，使用了 3 * 4 = 12 字节<br />
因此我们需要将栈顶指针恢复到 ESP + 12 处</p>
<p>现在可以通过 EAX 来获取子程序的返回值</p>
<p>如果调用方还需要原本 EAX, ECX, EDX 的值<br />
那么则应该在调用前将这些值存入栈<br />
并在子程序返回之后恢复这些值</p>
<h3 id="被调用方规则">被调用方规则</h3>
<p>下面的规则应用于子程序入口处</p>
<ol>
<li>
<p>使用下列的指令将 EBP 压入栈，并且将 ESP 的值复制到 EBP</p>
<pre><code class="language-asm">
push     EBP
mov      EBP, ESP
</code></pre>
</li>
<li>
<p>然后，为局部变量分配栈空间，即使用 <code>push</code> 指令将局部变量压入栈<br />
再次说明，栈往内存地址的低地址方向增长，所以为了获得空闲的内存区域<br />
栈顶指针应该减去值，应该减去的值由局部变量的数量与大小决定<br />
比如，如果有 3 个<em>整型</em>的局部变量，那么栈顶指针应该减去 3 * 4 = 12<br />
以获得足够的内存空间用于存储局部变量<br />
和参数相同一样，局部变量也能通过基于基指针的偏移获得</p>
</li>
<li>
<p>然后，保存一些<em>被调用方保存寄存器</em> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 的值<br />
因为这些寄存器的值可能会被修改<br />
因此，使用 <code>push</code> 将它们的值保存在栈中，这些寄存器是 EBX, EDI 和 ESI<br />
ESP 和 EBP 也属于这些寄存器的一部分，但它们在一开始（规则 1）就被保存了</p>
</li>
</ol>
<p>在完成上述 3 个规则的步骤后，子程序即可进行自己的流程<br />
当子程序需要返回时，它应该遵从下方的规则</p>
<ol>
<li>将返回值保存至 EAX</li>
<li>恢复被修改过的<em>被调用方保存寄存器</em>的值，通过 <code>pop</code> 指令将它们从栈中取出并恢复<br />
取出的顺序应和它们保存时的顺序相反（栈的先进后出原则）</li>
<li>删除局部变量，一个直接的方法即给栈顶指针加上在<em>分配过程中减去的值</em> <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup><br />
但是最不容易出错的方式是将基指针的值移动到栈顶指针中 <code>mov   ESP, EBP</code><br />
这是因为基指针的值永远是<em>在即将分配局部变量前</em>的栈顶指针的值</li>
<li>在即将返回前，使用 <code>pop</code> 指令恢复先前保存在栈中的旧的 EBP 的值<br />
这是属于调用方的 EBP，弹出 EBP 后，此时 ESP 指向返回地址</li>
<li>最后调用 <code>ret</code> 指令<br />
这个指令会读取 ESP 指向的返回的地址，将其地址存入指令寄存器，在返回后会删除此地址</li>
</ol>
<p>注意，被调用者的规则完全分为两半，它们基本上是彼此的镜像<br />
规则的前半部分适用于子程序的开头，通常被称为定义子程序的序言<br />
规则的后半部分适用于子程序的结尾，因此通常被称为定义子程序的结尾。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>指不能通过赋值的方式修改 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>或者叫做<em>程序状态字</em> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>这些寄存器被称作 caller-saved 寄存器 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>在内存中, 栈从高地址向低地址增长 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>这些寄存器被称作 “callee-saved registers” <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>即在子程序入口出的规则 2 中减去的值 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>笔记</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>我的主题介绍</title>
    <url>/2023/07/17/introduction-to-my-theme/</url>
    <content><![CDATA[<p>关于主题的介绍</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>这篇文章算是我在开发过程中的一些总结与吐槽。</p>
<p>其实一开始我认为对于博客来说，应当注重于文章本身，而不是花哨的样式，
这也是我一开始打算写一个自己的主题的原因。
但后面我发现，过于单调的界面很难让我阅读下去，
于是我在文章中为特殊的元素，如：链接、表格、代码等地方使用了彩色。
这确实使得文章好看了一些，也促使我为主题添加更多东西。</p>
<h2 id="写作">写作</h2>
<p>主题一开始就是基于Markdown渲染出的HTML文档进行开发，
因此对于普通的，用Markdown写出来的文章，主题的样式应该都是没什么问题的。</p>
<p>需要特别说明的是，在Hexo的文档<a href="https://hexo.io/docs/tag-plugins">标签插件</a>中提到了许多写作格式（或许可以这样子称呼？），
如：各种不同的引用、代码块以及图片视频等。
在我一开始开发主题时并没有看中这些方面的适配，但最近在对主题进行了一系列更新期间，
我发现了官方用于主题测试的一个<a href="https://hexojs.github.io/hexo-theme-landscape">示例</a>，
于是我决定重新设计一些主题的的样式，并现在几乎能够适配示例中提到的各种写作风格。</p>
<p><s><strong>除了那个<code>diff</code>样式，还有Hexo内置的带行号的代码高亮</strong>。</s>
现在gist的diff样式强制使用亮色，Hexo内置的代码高亮使用暗色。具体的介绍在后面有说。
<s>HTML标签一层又一层，真的难写，我本来就不会前端，越写越觉得写了个垃圾</s>。</p>
<h2 id="文章列表">文章列表</h2>
<p>主页文章列表以更新日期为顺序，展示了博客的所有文章，并提供访问文章的入口。</p>
<p>在Hexo中还有两种页面：标签页与分类页，这两种页面用于展示具有相同标签或者分类的文章。
在这两个页面中文章以发布时间作为排序顺序。</p>
<p>需要注意注意的是，在导航栏中指向的页面是用于展示博客拥有的标签或者分类，而不是展示文章的。</p>
<p>在官方示例中，我看到了几个我非常想要的样式：文章摘要、无标题文章、带封面文章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，
在主题中也实现了这些样式。</p>
<h3 id="一般文章">一般文章</h3>
<p>摘要<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>其实就是文章前的一小段文字，比如这篇文章的摘要就是“关于主题的介绍”，
不过我在这里使用了样式，但在文章列表里只会显示文字。</p>
<p>在一开始设计的主页文章列表中，所有的文章都显示为一个标题加上一段截取的文章内容。
其实我挺不满意这样的实现，因为Hexo提供的辅助函数会把标题也截进去，
更难受的是一些数学公式会因为被截断导致不能渲染出来。
而我又不想自己写函数处理这些文字，于是我决定采用摘要作为显示方式。</p>
<p>想要使用摘要，只需在文章内这样写：</p>
<pre><code class="language-markdown">这一段文字是摘要。

&lt;!-- more --&gt;

这里开始是正文
</code></pre>
<p>在标签<code>&lt;!-- more --&gt;</code>上的内容会作为摘要显示在文章列表中，同时在文章内也会显示。
需要注意的是，文章Front matter区域里边可以设置变量<code>excerpt</code>，
这将文章列表中代替文章内的摘要进行显示，而文章内的摘要不变。</p>
<h3 id="无标题文章">无标题文章</h3>
<p>对于一篇没有标题文章，我认为它的用途就像是能在列表的一篇篇的文章中，
起到类似于文章内“引用”的作用，你可以写一小段简短的话，作为一个“引用”插入到文章列表中，
不过其实好像没什么必要。</p>
<p>此外，我选择实现这种布局另一个原因是为了适配一下出现无标题文章的情况。
由于评论功能使用到了文章标题，因此在没有标题的文章里不能使用评论功能（这是强制性的）。</p>
<p>只需要把文章标题，也就是<code>title</code>设为空字符串就能使用这种样式。</p>
<h3 id="无分类文章">无分类文章</h3>
<p>在Hexo的配置文件中，设置<code>default_category: uncategorized</code>，
并使用<code>hexo new page uncategorized</code>创建页面。</p>
<p>在“分类”页面即可看到“未分类”选项，即可查看所有无分类的文章。</p>
<h3 id="带封面文章">带封面文章</h3>
<p>一开始其实是想写个像幻灯片一样布局来着的，
不过我发现这些图片只能在首页显示<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，或许更适合拿来作为文章封面。</p>
<blockquote>
<p>值得一提的是，关于这个样式使用到的变量<code>photos</code>只是在<a href="https://hexo.io/docs/variables.html#Page-Variables">这里</a>提到过，
<strong>而且还没告诉你怎么用…</strong></p>
</blockquote>
<p>要为文章添加封面，可以有以下几种方式</p>
<h4 id="全局封面">全局封面</h4>
<p>如果需要使用全局封面，需要在主题的配置文件中有如下配置：</p>
<pre><code class="language-yml">covers:
  - &quot;/covers/cover_1.jpg&quot;
  - &quot;/covers/cover_2.jpg&quot;
  - &quot;/covers/cover_3.jpg&quot;
</code></pre>
<p>使用绝对路径<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>填写需要作为封面的图片文件路径。
并需要在文章内启用：使用<code>cover: true</code>表示此文章使用默认封面。
如果文章还使用了<code>photos</code>指定封面，
那么设置<code>cover: true</code>会将全局封面添加进文章的封面列表。</p>
<h4 id="文章专有封面">文章专有封面</h4>
<p>所谓文章专有封面，其实就是使用<strong>文章资源文件夹</strong>下的图片作为封面。</p>
<p>这个方法需要在Hexo配置文件中启用<code>post_asset_folder</code>，
这会在创建文章时同时生成一个同名的文件夹，
把封面图片放入这个文件夹后，在Front matter区域添加：</p>
<pre><code class="language-yml">photos:
  - pic1.jpg
  - pic2.jpg
  - pic3.jpg
</code></pre>
<p>这样就能使用封面了，如果有多个封面，则会随机选取。</p>
<p>这个方法还能使用绝对路径指定不在文章资源文件夹下的文件作为封面：</p>
<pre><code class="language-yml">photos:
  - pic1.jpg
  - pic2.jpg
  - pic3.jpg
  - /img/pic4.jpg
</code></pre>
<p>使用<code>/</code>开始的文件路径，表示从网站根目录开始的绝对路径。</p>
<blockquote>
<p>比如：网站地址为<code>https://blog.example.com/</code>，
则表示<code>https://blog.example.com/img/pic4.jpg</code>。
网站地址为<code>https://example.com/blog/</code>，
则表示<code>https://example.com/blog/img/pic4.jpg</code>。</p>
</blockquote>
<h4 id="外部图片">外部图片</h4>
<p>如果不希望在博客上存储封面，还可以从网络上获取。在Front matter区域添加：</p>
<pre><code class="language-yml">photos:
  - https://via.placeholder.com/350x150.jpg
</code></pre>
<p>这样子就会从网络中获取封面。这个方式可以和之前的两种方式中的任意一个混合使用。</p>
<h4 id="相册集">相册集</h4>
<p>相册集可以看作是一种特殊的文章，它主要用于展示一些照片。
与普通的带封面的文章不同，相册集能够展示所有配置的照片，
而不是使用随机一张作为封面。
在使用<code>photos</code>配置好希望展示的图片后，
使用<code>gallery: true</code>启用相册集。</p>
<blockquote>
<p>你也可以同时启用<code>cover: true</code>，这将会展示网站配置的所有默认封面。
此外，也能够在<code>photo</code>使用网络图片。</p>
</blockquote>
<h3 id="外部文章">外部文章</h3>
<p>外部文章指的是不在自己博客网站上的文章，也可以是一般的其他网页。
外部文章有两种：一种是带标题的，另一种是不带标题的。</p>
<p>带标题的在显示时会显示标题，而不带标题的则直接显示链接。
使用方式如下：</p>
<pre><code class="language-yml"># 标题指定了就是带标题的，置空就是无标题的
title: &quot;&quot;
link: https://www.google.com
</code></pre>
<p>当点击时就会跳转到对应的网页，文章本身不会被访问（在考虑要不要实现访问的方式）。</p>
<h3 id="置顶文章">置顶文章</h3>
<p>这个功能其实本来不想写的，但就觉得主题里都塞那么多东西了，再加个文章置顶也无所谓，
于是就写了。</p>
<p>在文章Front matter区域添加如下字段即可：</p>
<pre><code class="language-yml">pin: true
</code></pre>
<p>如果有多个置顶的文章，文章将会按照更新日期排序。</p>
<h3 id="还在完善的文章">还在完善的文章</h3>
<p>先说怎么用吧，在文章Front matter区域添加：</p>
<pre><code class="language-yml">todo: true
todo_msg: &quot;&quot;
</code></pre>
<p>这样就行了，在文章列表中就能看到效果了。顺便解释一下：
<code>todo</code>设置为<code>true</code>表示文章还未完善，<code>todo_msg</code>可以写一些原因，留空表示使用默认消息。</p>
<blockquote>
<p>后面是关于这个功能实现的原因，不感兴趣的话就跳过吧。</p>
</blockquote>
<p>这个功能的实现纯属是突发奇想。原因就是这篇文章写到一半时又想着实现置顶、
修改一些样式或者更改一些其他的功能。导致这篇文章修修改改了几次。
闲着无聊实现了文章入口的那个更新日期指示后，就想着加多一个样式，
然后就选了这个。</p>
<p>其实本来想着按照更新日期来决定样式的，最近更新的就显示绿色，
一段时间前更新的就显示橙色，长时间没有更新的就显示红色。</p>
<p>但转念一想，文章写好了就是写好了，顶多来点错别字修改，
一般不需要一直修改或者更新，那时间长了都变成橙色或者红色，就感觉怪怪的。
于是就想到了这样的情况：文章没有写完，但已经能够发布了，后面只需要慢慢更新就行。
这就是这个功能实现的由来了。<s>实际上<code>todo_msg</code>还是在写这一小节时想出来的。</s></p>
<h2 id="一些功能">一些功能</h2>
<h3 id="知识共享授权">知识共享授权</h3>
<p>使用<code>creativecommons</code>字段配置授权。</p>
<pre><code class="language-yaml">creativecommons:
  license: &quot;CC BY-NC-ND 4.0&quot;
  link: &quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot;
  description: &quot;如无特殊说明，网站所有原创内容均采用#授权。&quot;
</code></pre>
<p><code>description</code>选项用于配置版权说明，
占位符<code>#</code>会被替换为<code>license</code>指定的授权协议名称，
并生成指向<code>link</code>配置的链接，</p>
<p>上述例子最终渲染的结果为：</p>
<pre><code class="language-html">&lt;p&gt;
  如无特殊说明，网站所有原创内容均采用
  &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;
    CC BY-NC-ND 4.0
  &lt;/a&gt;
  授权。
&lt;/p&gt;
</code></pre>
<h3 id="代码高亮">代码高亮</h3>
<h4 id="使用主题提供的代码高亮">使用主题提供的代码高亮</h4>
<ol>
<li>
<p>使用<a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a>
进行markdown文件渲染。</p>
</li>
<li>
<p>在<code>_config.yaml</code>中配置<a href="https://github.com/hexojs/hexo-renderer-markdown-it#options">hexo-renderer-markdown-it 选项</a></p>
</li>
<li>
<p>在主题的配置文件中启用代码高亮</p>
<pre><code class="language-yaml">hljs:
  enable: true
  # highlight.js CDN
  js: &quot;https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js&quot;
  # choose from https://github.com/highlightjs/highlight.js/tree/main/src/styles
  css:
    light: &quot;css/github.min.css&quot;
    dark: &quot;css/github-dark.min.css&quot;
</code></pre>
</li>
</ol>
<p>主题配置中，js和CSS资源可使用CDN或者本地资源
（上面的参考配置中，CSS使用的即本地资源）。</p>
<h4 id="使用Hexo内置的代码高亮">使用Hexo内置的代码高亮</h4>
<blockquote>
<p>目前主题对Hexo内置代码高亮的样式尚未实现，
仅支持使用highlght.js在浏览器进行渲染。
禁用Hexo内置高亮请参考：<a href="https://hexo.io/docs/syntax-highlight.html#Disabled">https://hexo.io/docs/syntax-highlight.html#Disabled</a>。</p>
</blockquote>
<p><s>如果需要使用Hexo内置的代码高亮，需要启用Hexo配置中的这两个选项：</s></p>
<blockquote>
<p>注：这是旧版本的Hexo开启内置高亮的方式。</p>
<pre><code class="language-yaml">highlight:
  enable: true
  hljs: true
</code></pre>
</blockquote>
<p><s>还需要注意的一点是，如果同时启用了主题的高亮与Hexo内置的高亮，
那么将会优先使用Hexo内置的代码高亮样式。</s></p>
<h3 id="搜索">搜索</h3>
<blockquote>
<p>搜索功能可能还会继续完善。</p>
</blockquote>
<p>搜索功能在主题的README.md中似乎说完了，不过还是在这里再一遍。</p>
<p>目前主题提供两种方式：关键字搜索以及正则搜索。</p>
<h4 id="关键字搜索">关键字搜索</h4>
<p>对于关键字搜索来说，可以使用<strong>查询规则</strong>。</p>
<h5 id="语法">语法</h5>
<ul>
<li><code>key1 + key2</code>将会搜索包含<code>key1</code>或者<code>key2</code>的文章，它们的并集作为搜索结果。</li>
<li><code>key1 &amp; key2</code>将会搜索同时包含<code>key1</code>和<code>key2</code>的文章。</li>
</ul>
<h5 id="优先级">优先级</h5>
<p><code>&amp;</code>符号优先级最高，其次是<code>+</code>，这意味着<code>key1 + key2 &amp; key3</code>的结果为：
<strong>包含key1的文章</strong>，以及<strong>同时包含key2和key3的文章</strong>。</p>
<blockquote>
<p>注：这个优先级规则可能会考虑更改，比如添加<code>()</code>来改变优先级。</p>
</blockquote>
<h4 id="正则搜索">正则搜索</h4>
<p>目前正则搜索<strong>不支持</strong>标记<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，在搜索过程中强制使用<code>g</code>标记进行搜索。</p>
<p>关于正则的语法请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>。</p>
<h3 id="评论">评论</h3>
<p>评论系统使用<a href="https://github.com/gitalk/gitalk">Gitalk</a>，可以在主题的配置文件中选择开启，
在启用评论系统的情况下，还应该<strong>在文章中配置开启</strong>。</p>
<p>在配置文件中：</p>
<pre><code class="language-yml">gitalk:
  enable: true
</code></pre>
<p>在文章中：</p>
<pre><code class="language-yml">gitalk: true
</code></pre>
<p><strong>只在配置文件中开启</strong>或者<strong>只在文章中开启</strong>将<strong>不会启用</strong>评论，此外没有标题的文章<strong>强制不启用</strong>。</p>
<h3 id="外链">外链</h3>
<p>你可以在顶栏添加一些社交网页链接。就像这样子：</p>
<pre><code class="language-yaml">links:
  github:
    title: &quot;Github&quot;
    class: &quot;bi bi-github&quot;
    url: &quot;https://github.com/HuzerOVO&quot;
</code></pre>
<p>主题主要使用<strong>Bootstrap Icons</strong>，但主题也使用<strong>Font Awesome</strong>作为图标的补充。</p>
<p>比如在Bootstrap icons中，没有BiliBili的图标，但在Font awesome中有，于是就可以这样子：</p>
<pre><code class="language-yml">links:
  bilibili:
    title: &quot;哔哩哔哩&quot;
    class: &quot;fa-brands fa-bilibili&quot;
    url: &quot;https://www.bilibili.com&quot;
</code></pre>
<p>需要说明的是，<code>class</code>字段根据Bootstrap Icons或者Font Awesome介绍的使用方式填写。</p>
<h3 id="订阅链接">订阅链接</h3>
<p>订阅链接可以使用<code>hexo-generator-feed</code>自动生成。</p>
<p>配置请参考：<a href="https://github.com/hexojs/hexo-generator-feed#options">hexo-generator-feed</a></p>
<h3 id="电子邮件">电子邮件</h3>
<p>字段<code>email</code>可以设置你的电子邮件，如果设置了电子邮件地址，
那么在网页的footer区域会显示一个链接用于向你发送邮件。</p>
<h2 id="“关于”页面">“关于”页面</h2>
<p>“关于”页面比较特殊，它几乎是套用了“文章”（post）的模板。
根据主题的页面配置指南，
应该存在这么一个文件：<code>your-blog-root-dir/source/about/index.md</code>。
这个文件可以像文章一样编辑，不过有这些不同：
你的<code>excerpt</code>会被作为个人的描述，并显示在头像下方，
其余内容则会像正常文章一样显示。</p>
<p>在关于页面，你可以使用<code>gitalk</code>和<code>katex</code>这两个变量。
不过不同于文章，你禁用了Gitalk后并不会显示“评论已禁用”这样子的提示框。</p>
<p>此外，不同与普通文章的是，你可以指定“关于”页面中的头像，
并在Front matter区域使用<code>avatar</code>指定头像文件名。</p>
<p>假设你此时文件夹结构如下：</p>
<pre><code>your-blog-root-dir
+--scaffolds
...
+--source
   +--about
      +--index.md
      +--avatar.jpg
</code></pre>
<p>此时index.md文件的Front matter区域可以这样设置：</p>
<pre><code class="language-yml"># 在关于页面，你可以使用一些文章布局的Front matter变量
# 比如gitalk、katex
gitalk: false
katex: false

# 这些是专有的
avatar: avatar.jpg
avatar_size: normal
</code></pre>
<p>对于变量<code>avatar_size</code>，主题内置了3个预设值：<code>small</code>、<code>normal</code>（这是默认值）以及<code>large</code>。
对应头像大小：64px，125px和256px。
此外你还可以设定一个数字指定头像大小，单位为<code>px</code>，如：</p>
<pre><code class="language-yml">avatar_size: 120
</code></pre>
<blockquote>
<p>需要注意的是，头像文件<strong>只能</strong>放在about文件夹里，并且不能指定多个头像。</p>
<p>此外，头像的长宽比应当是1:1的，否则显示会很怪。</p>
</blockquote>
<h2 id="Front-matter参考手册">Front matter参考手册</h2>
<p>这里列出主题使用到的，可能会影响文章布局的变量作为参考：</p>
<pre><code class="language-yml">title: 我的主题介绍
date: 2023-07-17 12:00:00
updated: 2023-12-31 09:17:43
toc: true
katex: false
gitalk: true
#issue_id: 46 # 指定issue用作评论区
todo: true
todo_msg: 主题仍在开发中
#excerpt: 主题仍在持续开发中 =v= # 这个会覆盖文章内摘要
pin: true
cover: false
gallery: false
photos:
  - id=89645004_p0.png
categories:
  - [开发记录]
tags:
  - 主题
  - Hexo
# 这个作为外部文章引用
#link: https://huzerovo.github.io/2023/07/17/introduction-to-my-theme/
</code></pre>
<p>对于“关于”页面则有：</p>
<pre><code class="language-yml">gitalk: false
#issue_id: 45
katex: false
avatar: avatar.jpg
avatar_size: normal
</code></pre>
<p>除了以上的变量，主题还用到了Hexo提供的一些内置变量，
比如<code>path</code>表示页面路径，<code>content</code>表示文章内容等。
不过这些变量并不影响文章布局，因此不一一列出了。</p>
<h2 id="配置文件参考手册">配置文件参考手册</h2>
<p>见<a href="https://github.com/HuzerOVO/hexo-theme-huzerovo">主题项目的README.md</a></p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>其实是示例中的Gallery，但我发现这些图片没有在文章中出现，或许更适合作为封面。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在官方文档中，
摘要在<a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">标签插件</a>一节中被提到。<strong>为什么不是写在“写作”一节呢？？？</strong> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>其实可以通过主题模板，使这些图片也能在文章内显示，但我还是更想让它作为文章封面。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>本篇文章的绝对路径指的是博客文件夹作为根目录的路径，
如果博客处于网站的一个子路径下：“<a href="https://example.com/blog/%E2%80%9D%EF%BC%8C">https://example.com/blog/”，</a>
那“/covers/cover_1.jpg”会解析为“<a href="https://example.com/blog/covers/cover_1.jpg%E2%80%9D">https://example.com/blog/covers/cover_1.jpg”</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>一个正则表达式可以视为这种结构<code>/regex/flags</code>，这里的标记就是指<code>flags</code>，如<code>g</code>，<code>i</code>等。 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>开发记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Markdown</title>
    <url>/2020/11/08/learn-markdown/</url>
    <content><![CDATA[<p><s>Markdown学习笔记</s>，更新后算是个人习惯写法，使用<code>hexo-randerer-markdown-it</code>渲染。</p>
<span id="more"></span>
<blockquote>
<p>注意，使用<a href="https://github.com/markdown-it/markdown-it">markdown-it</a>作为渲染
引擎，因此部分语法可能略有差异。</p>
</blockquote>
<h2 id="好习惯">好习惯</h2>
<p>在每个不同的Markdown文本块<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>之间使用空行或许是个好习惯。</p>
<h2 id="标题">标题</h2>
<p>用不同数量的<code>#</code>标记，一个<code>#</code>表示一级标题，两个表示二级，以此类推。
一般使用这个方法。</p>
<pre><code class="language-markdown"># 一级标题

## 二级标题

### 三级标题

#### 四级标题

##### 五级标题

###### 六级标题
</code></pre>
<blockquote>
<p>使用<code>---</code>或者<code>===</code>会识别将上一行为一级标题。由于<a href="#%E5%A5%BD%E4%B9%A0%E6%83%AF">好习惯</a>，
我并不推荐使用这种方式。
个人习惯是在标题的上下都添加一个空行。
此外<code>---</code>还能用作<a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a>。</p>
</blockquote>
<h2 id="段落">段落</h2>
<p>在段落之间添加一个空行，另外，在行尾添加空格，
下一行也会被识别为新的段落，因此需要注意避免在行尾留后空格。</p>
<pre><code class="language-markdown">这是一个段落

这是另一个段落
</code></pre>
<h2 id="粗体与斜体">粗体与斜体</h2>
<p>使用<code>*</code>可将一段文字标注为粗体或者斜体。</p>
<pre><code class="language-markdown">*斜体*
*斜体*

**粗体**
**粗体**

***斜粗体***
***斜粗体***
</code></pre>
<blockquote>
<p>注意<code>_</code>也能够用于以上目的，且可与<code>*</code>混用。
但考虑到在一般的写作中<code>_</code>比<code>*</code>常用，因此我不推荐使用。</p>
</blockquote>
<h2 id="分隔线">分隔线</h2>
<p>我一般使用<code>-</code>作为分割线。</p>
<pre><code class="language-markdown">---
</code></pre>
<blockquote>
<p><code>_</code>与<code>*</code>也能够用于以上目的，由于<code>_</code>在一般的写作中比较常用，<code>*</code>用于字体样式，
因此推荐使用<code>-</code>。需要注意的是，<code>-</code>会将上一行作为空行，
因此使用空行是一个<a href="#%E5%A5%BD%E4%B9%A0%E6%83%AF">好习惯</a></p>
</blockquote>
<h2 id="删除线">删除线</h2>
<p>显示删除线效果，用两个 <code>~</code> 包裹要标注的文字</p>
<pre><code class="language-markdown">~~可以单独一行~~

也可以~~行内~~使用。
</code></pre>
<h2 id="脚注">脚注</h2>
<blockquote>
<p>使用<code>markdown-it-footnote</code></p>
</blockquote>
<p>可以对文本进行补充说明，也可以说是注释。</p>
<pre><code class="language-markdown">后面的是脚注[^脚注]

[^脚注]: 这是一个脚注!
</code></pre>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<p>数字加<code>.</code>可表示一个有序列表。</p>
<blockquote>
<p>注意，数字可以不按数学顺序排列，但应以数字 1 开始。
<s>谁会用乱序数字当有序列表啊。</s></p>
</blockquote>
<pre><code class="language-markdown">1. 第一项使用数字`1`作为起始序号
1. 后面可以随便使用数字
1. 第二项，
   接在后面的文本。
1. 第三项

   空行加带缩进的文本可以对齐列表项换行。如果出现了这种格式，
   那么整个列表会被认为带有*标题*，也就是序号后面的那段文字。
   而后面这些会被认为是这一个*标题*下的内容。
1. 第四项，这后面有两个空格  
   这会使这行文字带缩进。很难看出来，最好少用。

空行加一段没有缩进的一句话，可以表示列表结束

1. 这里又是新的列表
2. 序号重新从1开始
3. 由于没有出现空行+缩进，
   这个列表是没有标题的。
4. 这后面有两个空格  
   也会使这行文字带缩进。很难看出来，最好少用。
</code></pre>
<p>以上代码的渲染效果：</p>
<ol>
<li>
<p>第一项使用数字<code>1</code>作为起始序号</p>
</li>
<li>
<p>后面可以随便使用数字</p>
</li>
<li>
<p>第二项，
接在后面的文本。</p>
</li>
<li>
<p>第三项</p>
<p>空行加带缩进的文本可以对齐列表项换行。如果出现了这种格式，
那么整个列表会被认为带有<em>标题</em>，也就是序号后面的那段文字。
而后面这些内容会被认为是这一个<em>标题</em>下的内容</p>
</li>
<li>
<p>第四项，这后面有两个空格<br />
这会使这行文字带缩进。很难看出来，最好少用。</p>
</li>
</ol>
<p>空行加一段没有缩进的一句话，可以表示列表结束</p>
<ol>
<li>这里又是新的列表</li>
<li>序号重新从1开始</li>
<li>由于没有出现空行+缩进，
这个列表是没有标题的。</li>
<li>这后面有两个空格<br />
也会使这行文字带缩进。很难看出来，最好少用。</li>
</ol>
<h3 id="无序列表">无序列表</h3>
<p>用 <code>*</code> 或 <code>-</code> 或 <code>+</code> 标记一个无序列表，可以混用，我一般使用<code>-</code>。</p>
<pre><code class="language-markdown">- 第一项
- 第二项

* 第一项
* 第二项

- 第一项
- 第二项
</code></pre>
<h2 id="注释块">注释块</h2>
<p>用 <code>&gt;</code> 表示注释块。</p>
<pre><code class="language-markdown">&gt; 注释块
</code></pre>
<h2 id="代码">代码</h2>
<h3 id="行内代码">行内代码</h3>
<p>在段落上嵌入的代码，用反引号包裹代码。</p>
<pre><code class="language-markdown">C语言入口函数:`main()`
</code></pre>
<h3 id="代码块">代码块</h3>
<p>一段代码可以使用三个反引号包裹代码段，可以在前三个反引号后指定代码语言，
这里由于渲染原因，使用<code>'</code>代替例子中的反引号。</p>
<pre><code class="language-markdown">'''c
#include &lt;stdio.h&gt;
int main()
&#123;
  printf(&quot;Hello world&quot;);
  return 0;
&#125;
'''
</code></pre>
<p>还有一个不推荐的方法：使用空格或者制表符（TAB键）缩进。</p>
<h2 id="嵌套">嵌套</h2>
<p>大部分Markdown文本块<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>都能够相互嵌套。
但在Markdown代码块中不能嵌套另一个代码块，
这也是在<a href="#%E4%BB%A3%E7%A0%81%E5%9D%97">代码块</a>中使用<code>'</code>代替的原因。</p>
<h2 id="链接">链接</h2>
<p><code>[链接名字](链接地址)</code>或者<code>&lt;链接地址&gt;</code></p>
<pre><code class="language-markdown">就像这样：
[ME](https://huzerovo.github.io)

&lt;https://huzerovo.github.io\&gt;
</code></pre>
<blockquote>
<p>如果使用了anchor，还可以<code>[标题](#标题)</code>这样子在文章内进行跳转。</p>
</blockquote>
<h2 id="图片">图片</h2>
<p><code>![alt属性文本(注:找不到图片时显示的文字)](图片地址 &quot;标题&quot;)</code>，标题可写可不写。</p>
<pre><code class="language-markdown">就像这样：
![不愧是我.jpg](https://pixiv.cat/89004882-4.jpg)
</code></pre>
<h2 id="表格">表格</h2>
<p>用 <code>|</code> 划分列
用 <code>-</code> 划分表头和其他行</p>
<p>可以设置对其方式:
<code>-:</code> 整列右对齐
<code>:-</code> 整列左对齐
<code>:-:</code> 整列居中对齐</p>
<pre><code class="language-markdown">| 表头1 | 表头2 | 表头3 |
| :---- | ----: | :---: |
| 靠左  |  靠右 | 居中  |
| 列1   |   列2 |  列3  |
</code></pre>
<h2 id="其他">其他</h2>
<h3 id="使用HTML标签">使用HTML标签</h3>
<p>Markdown支持部分html标签，直接在文件写HTML标签即可。</p>
<h3 id="反斜杠转义">反斜杠转义</h3>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">符号名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">反斜线</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">反引号</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">星号</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">下划线</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">花括号</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">方括号</td>
</tr>
<tr>
<td style="text-align:left">()</td>
<td style="text-align:left">小括号</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">井字号</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加号</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减号</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">英文句点</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">感叹号</td>
</tr>
</tbody>
</table>
<h2 id="拓展语法">拓展语法</h2>
<p>拓展语法，可能不受一些Markdown编辑器或渲染器的支持，附带渲染效果</p>
<h3 id="任务列表">任务列表</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-task-lists">markdown-it-task-lists</a></p>
<pre><code class="language-markdown">- [x] first
- [ ] seconde
- [ ] next
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> first</li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> seconde</li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> next</li>
</ul>
<h3 id="下划线">下划线</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-ins">markdown-it-ins</a></p>
<pre><code class="language-markdown">++下划线在这里++
</code></pre>
<p><ins>下划线在这里</ins></p>
<h3 id="行内脚注">行内脚注</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-footnote">markdown-it-footnote</a></p>
<pre><code class="language-markdown">这是一个行内脚注^[不需要为脚注命名了]。
</code></pre>
<p>这是一个行内脚注<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<h3 id="缩写">缩写</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-abbr">markdown-it-abbr</a></p>
<pre><code class="language-markdown">*[HTML]: Hyper Text Markup Language
*[W3C]: World Wide Web Consortium
The HTML specification
is maintained by the W3C.
</code></pre>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification
is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="高亮">高亮</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-mark">markdown-it-mark</a></p>
<pre><code class="language-markdown">在这一行文字中，==这里==会被高亮。
</code></pre>
<p>在这一行文字中，<mark>这里</mark>会被高亮。</p>
<h3 id="上-下标">上/下标</h3>
<p>使用<a href="https://github.com/markdown-it/markdown-it-sup">markdown-it-sup</a>以及<a href="https://github.com/markdown-it/markdown-it-sub">makrdown-it-sub</a></p>
<pre><code class="language-markdown">这里有个^上标^

而这里有个~下标~
</code></pre>
<p>这里有个<sup>上标</sup></p>
<p>而这里有个<sub>下标</sub></p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>指的是“标题”、“段落”、“分隔线”、“引用块”、“列表”等等。 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>不需要为脚注命名了 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>笔记</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2021/09/11/linear-regression/</url>
    <content><![CDATA[<p>基于Andrew NG机器学习公开课程<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。
线性回归是一种<strong>监督学习</strong>的模型。</p>
<span id="more"></span>
<h2 id="基础">基础</h2>
<h3 id="定义“特征”与“标签”">定义“特征”与“标签”</h3>
<p>定义一些概念，方便后面的表达：</p>
<ul>
<li>特征，定义为输入空间（特征空间）。</li>
<li>标签，定义为输出空间。</li>
</ul>
<p>对“特征”与“标签”的理解：</p>
<ol>
<li>
<p>从算法定义上：</p>
<ul>
<li>特征可理解为输入。</li>
<li>标签可理解为输出。</li>
<li>算法的目的就是根据输入，给出输出。</li>
</ul>
</li>
<li>
<p>从直观感觉上：</p>
<ul>
<li>特征指代一个对象的特点。</li>
<li>标签指代一个对象。</li>
<li>算法的目的即根据特点，猜测对象。</li>
</ul>
</li>
</ol>
<h3 id="定义“特征-标签”关系">定义“特征-标签”关系</h3>
<p>实际生活中，我们知道了$ A $，$ B $能够在某种程度上决定$ C $，
且$ A $，$ B $各自对$ C $的影响有多大，我们并不清楚。
也就是说，我们知道“特征”与“标签”之间存在某种关系，但无法准确地描述这个关系。
此时我们可以对$ A $，$ B $，$ C $建立一个关系，即：能由$ A $，$ B $推出$ C $。
使用数学符号表示：$ (A, B) \Rightarrow C $</p>
<p>若将$ A $和$ B $称做$ C $的特征，并且将$ C $定义为标签，
将$ (A, B) \Rightarrow C $称为“特征-标签”关系，
则称数据$ (A, B, C) $存在“特征-标签”关系</p>
<h3 id="提出问题">提出问题</h3>
<p>我们希望，给出一组存在“特征-标签”的关系的数据，
计算机能够根据这组数据，建立一个存在“特征-标签”关系的模型,
随后给出“特征”，计算机能够根据模型，给出比较可靠的、推测的“标签”。</p>
<h3 id="使用数学语言描述问题">使用数学语言描述问题</h3>
<p>接下来将问题抽象成为一个数学问题。
设所有的特征的集合为$ (x*{1}, x*{2}, \cdots, x_{n}) $，其中$ n $表示特征的数量，
$ y $为特征对应的“标签”。
在比较简单的情况下，假定“特征-标签”是线性关系，并且这个线性关系为函数$ h $，
则称$ h $为<strong>假设函数（hypotheses）</strong>。
于是得到的函数：</p>
<p>$$
\begin{equation}
h_{\theta}(x) = \theta_{0} + \theta_{1} \cdot x_{1} +
\theta_{2} \cdot x_{2} + \cdots + \theta_{n} \cdot x_{n}
\end{equation}
$$</p>
<p>其中，$ \theta*{0} $，$ \theta*{1} $，$ \cdots $，$ \theta_{n} $
表示<strong>参数（parameters）</strong>，或者说是<strong>权值（weights）</strong>,
这是我们需要求得的值。</p>
<h3 id="引入向量进行表达">引入向量进行表达</h3>
<p>若用向量表示$ \theta $：</p>
<p>$$
\vec{\theta} =
\begin{pmatrix}
\theta_{0}\\
\theta_{1}\\
\vdots\\
\theta_{n}
\end{pmatrix}
$$</p>
<p>并将特征集合重新定义为特征向量：</p>
<p>$$
\vec{x} =
\begin{pmatrix}
x_{0}\\
x_{1}\\
\vdots\\
x_{n}
\end{pmatrix}
$$</p>
<p>其中$ x_{0} = 1 $，
**为简化符号，记$ \vec{\theta} $为$ \theta $，$ \vec{x} $为$ x $**，
则函数可表示为：</p>
<p>$$
\begin{equation}
h_{\theta}(x) = \sum_{i=0}^{n}{\theta_{i} x_{i}} = \theta^{T}x
\end{equation}
$$</p>
<p>此时我们的问题就是，求出一个$ \theta $，使得函数$ h $能够很好地描述“特征-标签”关系，
即建立一个合理的模型。</p>
<h2 id="进一步分析问题">进一步分析问题</h2>
<h3 id="引入数据集与训练集的概念">引入数据集与训练集的概念</h3>
<p>上面的函数仅表示单个数据中的“特征与标签”关系，
若存在多个数据，即<strong>数据集（dataset）</strong>，
且所有的数据都存在“特征-标签”的关系，
即可以构建出一个<strong>训练集（training set）</strong>，
那么我们可以使用<strong>训练集</strong>对算法进行<strong>训练</strong>，最终得出$ \theta $。</p>
<p>定义下面的符号，方便之后的表示：</p>
<p>设训练集大小为$ m $，令$ x*{i}^{(j)} $表示训练集中第$ j $项数据的第$ i $个特征，
$ x^{(j)} $表示训练集中第$ j $项数据的特征向量。
同理可得$ \theta*{i}^{(j)} $与$ \theta^{(j)} $。</p>
<h3 id="引入最小二乘法转化问题">引入最小二乘法转化问题</h3>
<p>回顾我们的问题：
我们希望得到一个函数$ h $能够很好地描述训练集中的每个数据中“特征-标签”的关系
换句话说，给出“特征”，若“特征”存在于训练集中，那么
由**函数$ h $<strong>得出的“标签”，与训练集中的“标签”，它们之间的误差最小
根据</strong>最小二乘法**，得：</p>
<p>$$
\begin{equation}
J(\theta) = \frac{1}{2} \sum_{i=1}^{m} \left( h_{\theta}(x^{(i)}) - y^{(i)} \right)^{2}
\end{equation}
$$</p>
<p>函数$ J $也称为<strong>cost function</strong></p>
<p>于是问题转化为：
需要得到一个$ \theta $，使得$ J(\theta) $的值最小</p>
<h3 id="为什么使用最小二乘法">为什么使用最小二乘法</h3>
<p>参考文章 <a href="/2021/11/04/why-use-least-squares/" title="为什么使用最小二乘法">为什么使用最小二乘法</a></p>
<h2 id="解决问题">解决问题</h2>
<p>接下来介绍解决这个问题的可行方法</p>
<h3 id="梯度下降">梯度下降</h3>
<blockquote>
<p>注：梯度下降算法在 <a href="/2021/09/16/gradient-descent/" title="梯度下降算法">另一篇文章</a> 中有介绍</p>
</blockquote>
<p>为了得到$ \theta $使函数值$ J(\theta) $最小，可以采取**梯度下降 (gradient descent)**的方法：
随机选取一个$ \theta $值，随后不断地更新$ \theta $，使$ J(\theta) $不断减小，
当$ J(\theta) $的值达到最小时，得到的$ \theta $即是问题的解</p>
<p>我们可以这样进行更新：</p>
<p>$$
\begin{equation}
\theta_{j} := \theta_{j} - \alpha \frac {\partial}{\partial \theta_{j}} J(\theta)
\label{eq4}
\end{equation}
$$</p>
<p>其中$ := $表示赋值，将右边的值赋予左边，而$ = $是真值判断，表示等号两边的值或结果是相同的
$ \alpha $表示<strong>学习率 (learning rate)</strong>，或者称<strong>步长</strong>，是自定义的常数</p>
<p>对$ J(\theta) $进行偏导：</p>
<p>$$
\begin{equation}
\begin{split}
\frac{\partial}{\partial \theta_{j}} J(\theta)
&amp;= \frac{\partial}{\partial \theta_{j}} \frac {1}{2} (h_{\theta}(x) - y)^2 \\
&amp;= 2 \cdot \frac{1}{2}(h_{\theta}(x) - y) \cdot
\frac{\partial}{\partial \theta_{j}} (h_{\theta}(x) - y) \\
&amp;= (h_{\theta}(x) - y) \cdot \frac{\partial}{\partial \theta_{j}}
\left( \sum_{i=0}^{n} \theta_{i} x_{i} - y \right) \\
&amp;= (h_{\theta}(x) - y) x_{j}
\end{split}
\end{equation}
$$</p>
<p>代入$ \eqref{eq4} $，得：</p>
<p>$$
\begin{equation}
\theta_{j} := \theta_{j} - \alpha (h_{\theta}(x) - y) x_{j}
\end{equation}
$$</p>
<p>这是单个数据的表示，引入上面介绍的训练集</p>
<p>$$
\begin{equation}
\theta_{j} := \theta_{j} - \alpha \sum_{i=1}^{m} \left(h_{\theta}(x^{(i)})
- y^{(i)}\right) x_{j}^{(i)}
\end{equation}
$$</p>
<p>对每一个在向量$ \theta $中的分量$ \theta_{j} $都进行上述运算
最终我们会得到一个$ \theta $，这个值就是我们希望求得的值</p>
<h3 id="牛顿法">牛顿法</h3>
<blockquote>
<p>尚未完成，咕咕咕ing</p>
</blockquote>
<p>因为极值点处的一阶导数为 0 ，
且$ J(\theta) $的函数最高次为二次，函数只存在一个极值点
所以，为了得到$ J(\theta) $的最小值，我们可以使用间接的方法，
即：寻找$ J(\theta) $导数的零点</p>
<p>牛顿法的步骤为：</p>
<blockquote>
<p>设函数为$ f(x) $</p>
<ol>
<li>随机在函数$ f(x) $上取一初始点$ P_{0} $</li>
<li>过点$ P_{0} $作函数$ f(x) $的切线$ L $</li>
<li>找到切线$ L $与$ x $轴的交点$ Q_{0} $</li>
<li>过交点$ Q*{0} $作$ x $轴的垂线，并与函数有一交点$ P*{1} $</li>
<li>将点$ P_{1} $作为初始点，回到步骤 2</li>
<li>当点$ P*{n} $与点$ Q*{n} $重合时，横坐标即零点</li>
</ol>
</blockquote>
<h3 id="解析解法">解析解法</h3>
<p>实际上，上面的两种方法得到的是一个近似值，
但其精确度能够满足实际应用，
而解析解法能够直接计算出精确值</p>
<h4 id="符号定义">符号定义</h4>
<blockquote>
<p>这里的定义均来自 Andrew NG 课程讲义</p>
</blockquote>
<h5 id="定义矩阵函数的导函数">定义矩阵函数的导函数</h5>
<p>对于函数$ f $:$ \mathbb{R}^{m \times n} \mapsto \mathbb{R} $，
即$ m \times n $的矩阵映射至实数的函数关系
定义函数$ f $对矩阵$ A $的导数为：</p>
<p>$$
\begin{equation}
\nabla_{A}f(A) =
\begin{bmatrix}
\frac{\partial{f}}{\partial A_{11}} &amp; \cdots &amp;
\frac{\partial{f}}{\partial A_{1n}} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial{f}}{\partial A_{m1}} &amp; \cdots &amp;
\frac{\partial{f}}{\partial A_{mn}} \\
\end{bmatrix}
\end{equation}
$$</p>
<p><em>例子</em>
若矩阵
$
A =
\begin{bmatrix}
A_{11} &amp; A_{12} \\
A_{21} &amp; A_{22}
\end{bmatrix}
$，
函数$ f(A) = \frac{3}{2} A*{11} + 5A*{12}^{2} + A*{21}A*{22} $，
那么
$
\nabla*{A} f(A) =
\begin{bmatrix}
\frac{3}{2} &amp; 10A*{12} \\
A*{22} &amp; A*{21}
\end{bmatrix}
$</p>
<h5 id="定义-trace-运算">定义 trace 运算</h5>
<p><code>trace</code> 运算简写为 <code>tr</code>
对于$ n \times n $的矩阵$ A $，定义</p>
<p>$$
\begin{equation}
\mathrm{tr}A = \sum_{i=1}^{n}A_{ii}
\end{equation}
$$</p>
<p>可以知道， <code>trace</code> 运算具有下列运算法则</p>
<p>$$
\begin{equation}
\label{algorithm1}
\mathrm{tr}ABC = \mathrm{tr}CAB = \mathrm{tr}BCA
\end{equation}
$$</p>
<p>$$
\begin{equation}
\label{algorithm2}
\mathrm{tr}(A+B) = \mathrm{tr}A + \mathrm{tr}B
\end{equation}
$$</p>
<p>$$
\begin{equation}
\label{algorithm3}
\mathrm{tr}aA = a\mathrm{tr}A
\end{equation}
$$</p>
<p>其中$ a $是一个实数</p>
<h4 id="一些定理">一些定理</h4>
<p>一些<strong>trace 运算</strong>与<strong>矩阵导函数</strong>相关的定理，
仅列出<strong>解析式推导过程</strong>需要用到的一些定理，不作证明，</p>
<p>$$
\begin{equation}
\label{theorem1}
\nabla_{A} \mathrm{tr}AB = B^{T}
\end{equation}
$$</p>
<p>$$
\begin{equation}
\label{theorem2}
\nabla_{A^{T}} f(A) = (\nabla_{A}f(A))^{T}
\end{equation}
$$</p>
<p>$$
\begin{equation}
\label{theorem3}
\nabla_{A} \mathrm{tr} A B A^{T} C = C A B + C^{T} A B^{T}
\end{equation}
$$</p>
<p>$$
\begin{equation}
\label{theorem4}
\nabla_{A} |A| = |A| ( A^{-1} )^{T}
\end{equation}
$$</p>
<h4 id="解析式推导">解析式推导</h4>
<p>使用矩阵表达“特征”与“标签”
定义矩阵$ X $和$ Y $</p>
<p>$$
\begin{equation}
X =
\begin{bmatrix}
( x^{(1)} )^{T} \\
( x^{(2)} )^{T} \\
\vdots \\
( x^{(m)} )^{T}
\end{bmatrix}
,
Y =
\begin{bmatrix}
y^{(1)} \\
y^{(2)} \\
\vdots \\
y^{(m)}
\end{bmatrix}
\end{equation}
$$</p>
<blockquote>
<p>注意，此处$ x $表示向量$ \vec{x} $，$ y $表示特征</p>
</blockquote>
<p>因为$ h_{\theta}(x^{(i)}) = \theta^{T} x^{(i)} = ( x^{(i)} )^{T} \theta $，故</p>
<p>$$
\begin{equation}
h_{\theta}(x)=
\begin{bmatrix}
( x^{(1)} )^{T} \theta \\
( x^{(2)} )^{T} \theta \\
\vdots \\
( x^{(m)} )^{T} \theta
\end{bmatrix}
= X \theta
\end{equation}
$$</p>
<p>又因为</p>
<p>$$
\begin{equation}
X \theta - Y =
\begin{bmatrix}
( x^{(1)} )^{T} \theta \\
( x^{(2)} )^{T} \theta \\
\vdots \\
( x^{(m)} )^{T} \theta
\end{bmatrix} -
\begin{bmatrix}
y^{(1)} \\
y^{(2)} \\
\vdots \\
y^{(m)}
\end{bmatrix} =
\begin{bmatrix}
h_{\theta}(x^{(1)}) - y^{(1)} \\
h_{\theta}(x^{(2)}) - y^{(2)} \\
\vdots \\
h_{\theta}(x^{(m)}) - y^{(m)}
\end{bmatrix}
\end{equation}
$$</p>
<p>且对于矩阵$ z $，有$ z^{T}z = \sum*{i} z*{i}^{2} $，
于是可得</p>
<p>$$
\begin{equation}
\begin{split}
\frac{1}{2} (X \theta - Y)^{T} (X \theta - Y)
&amp;= \frac{1}{2} \sum_{i = 1}^{m} ( h_{\theta}(x^{(i)}) - y^{(i)} )^{2} \\
&amp;= J(\theta)
\end{split}
\end{equation}
$$</p>
<p>根据$ \eqref{theorem2} $和$ \eqref{theorem3} $，有</p>
<p>$$
\begin{equation}
\label{inference1}
\nabla_{A^{T}} \mathrm{tr} AB A^{T} C = B^{T} A^{T} C^{T} + B A^{T} C
\end{equation}
$$</p>
<p>于是</p>
<p>$$
\begin{equation}
\begin{split}
\nabla_{\theta} J(\theta)
&amp;= \nabla_{\theta} \frac{1}{2} ( X \theta - Y )^{T} (X \theta - Y) \\
&amp;= \frac{1}{2} \nabla_{\theta} ( \theta^{T} X^{T} X \theta -
\theta^{T} X^{T} Y - Y^{T} X \theta + Y^{T} Y ) \\
&amp;= \frac{1}{2} \nabla_{\theta} \mathrm{tr} ( \theta^{T} X^{T} X \theta -
\theta^{T} X^{T} Y - Y^{T} X \theta + Y^{T} Y ) \\
&amp;= \frac{1}{2} \nabla_{\theta} ( \mathrm{tr} \theta^{T} X^{T} X \theta -
2 \mathrm{tr} Y^{T} X \theta ) \\
&amp;= \frac{1}{2} ( X^{T} X \theta + X^{T} X \theta - 2 X^{T} Y ) \\
&amp;= X^{T}  X \theta - X^{T} Y
\end{split}
\end{equation}
$$</p>
<p>第三步将
$(\theta^{T} X^{T} X \theta - \theta^{T} X^{T} Y - Y^{T} X \theta +
Y^{T} Y )$
视作整体，
可知这是一个实数，可将其看作一个
$ 1 \times 1 $的矩阵$ A = \begin{bmatrix}a\end{bmatrix} $，
由 <code>trace</code> 定义可知$ \mathrm{tr} A = a $</p>
<p>第四步使用了$ \mathrm{tr} A = \mathrm{tr} A^{T} $，
且由于$ Y^{T}Y $项不存在$ \theta $，求导后为$ 0 $</p>
<p>第五步中使用了$ \eqref{theorem1} $和$ \eqref{inference1} $，
视$ A^{T} = \theta $，$ B = B^{T} = X^{T} X $,$ C = I $</p>
<p>使$ J(\theta) $最小，则令$ \nabla_{\theta} J(\theta) = 0 $，
所以有$ X^{T} X \theta = X^{T} Y $
因此，得$ \theta = ( X^{T}X )^{-1} X^{T} Y $</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>课程链接 <a href="https://see.stanford.edu/Course/CS229">https://see.stanford.edu/Course/CS229</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>监督学习</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 防火墙</title>
    <url>/2021/02/18/linux-firewall/</url>
    <content><![CDATA[<p>本文仅对防火墙进行简单的介绍，方便回顾</p>
<span id="more"></span>
<h2 id="Netfilter-Porject">Netfilter Porject</h2>
<p>Netfilter 项目是一个开源项目，目的是为 Linux 内核提供进行包过滤的功能</p>
<blockquote>
<p>官网<a href="https://www.netfilter.org">Netfilter Project</a>介绍原文:<br />
“<em>The netfilter project is a community-driven collaborative FOSS project that
provides packet filtering software for the Linux 2.4.x and later kernel series.
The netfilter project is commonly associated with iptables.</em>”</p>
</blockquote>
<h2 id="四表五链概念">四表五链概念</h2>
<blockquote>
<p>参考 <code>man iptables</code>，以及网络资料</p>
</blockquote>
<p>存在 <code>表(tables)</code>、<code>链(chain)</code> 和 <code>规则(rules)</code> 三个层面</p>
<ul>
<li><code>表(tables)</code> 指的是不同类型的数据包处理流程，<code>表</code> 中可以存在多个 <code>链</code></li>
<li><code>链(chain)</code> 中包含若干 <code>规则</code></li>
<li><code>规则(rules)</code> 规定数据包的处理方式</li>
</ul>
<p>系统接收到数据包时将根据 <code>链</code> 中的 <code>规则</code> 将包通过 <code>链</code></p>
<h3 id="四表">四表</h3>
<p>四表用于管理链路规则</p>
<table>
<thead>
<tr>
<th style="text-align:left">表名</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Filter表</td>
<td style="text-align:left">过滤数据包</td>
</tr>
<tr>
<td style="text-align:left">NAT表</td>
<td style="text-align:left">用于网络地址转换</td>
</tr>
<tr>
<td style="text-align:left">Mangle表</td>
<td style="text-align:left">修改数据包服务类型、TTL、并且可以配置路由实现QOS</td>
</tr>
<tr>
<td style="text-align:left">Raw表</td>
<td style="text-align:left">决定数据包是否被状态跟踪机制处理</td>
</tr>
</tbody>
</table>
<h3 id="五链">五链</h3>
<p>五条链用于存放链路规则</p>
<table>
<thead>
<tr>
<th style="text-align:left">链名</th>
<th style="text-align:left">作用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INPUT链</td>
<td style="text-align:left">进来的数据包</td>
</tr>
<tr>
<td style="text-align:left">OUTPUT链</td>
<td style="text-align:left">发出的数据包</td>
</tr>
<tr>
<td style="text-align:left">FORWARD链</td>
<td style="text-align:left">转发的数据包</td>
</tr>
<tr>
<td style="text-align:left">OREROUTING链</td>
<td style="text-align:left">作路由选择前的数据包</td>
</tr>
<tr>
<td style="text-align:left">POSTROUNTING链</td>
<td style="text-align:left">作路由选择后的数据包</td>
</tr>
</tbody>
</table>
<h3 id="四表五链之间的联系">四表五链之间的联系</h3>
<p>四表里存放的是功能一致的规则，即存放着链<br />
表中存放的规则如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">Filter表</th>
<th style="text-align:left">NAT表</th>
<th style="text-align:left">Mangle表</th>
<th style="text-align:left">Raw表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INPUT链</td>
<td style="text-align:left">OUTPUT链</td>
<td style="text-align:left">INPUT链</td>
<td style="text-align:left">OUTPUT链</td>
</tr>
<tr>
<td style="text-align:left">OUTPUT链</td>
<td style="text-align:left">PREROUTING链</td>
<td style="text-align:left">OUTPUT链</td>
<td style="text-align:left">PREROUTING链</td>
</tr>
<tr>
<td style="text-align:left">FORWARD链</td>
<td style="text-align:left">POSTROUTING链</td>
<td style="text-align:left">FORWARD链</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">PREROUTING链</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">POSTROUTING链</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="管理-firewall">管理 firewall</h2>
<p>下面列出的是运用最广泛的防火墙管理软件，以及他们之间的联系</p>
<ul>
<li><code>netfilter</code> 是一个 Linux 内核的软件框架<br />
用于管理网络数据包<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，运行在内核空间</li>
<li><code>iptables</code> 是运行在用户空间的软件<br />
通过控制 netfilter 模块来管理网络数据包的处理和转发<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li>
<li><code>nftables</code> 是 iptables 的后继者<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li>
<li><code>uncomplicated ftrewall(UFW)</code> 的使用更加简单方便<br />
依赖于 iptables 来管理网络包<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></li>
<li><code>firewalld</code> 作为 nftables 的前端，并通过其来管理网络包<br />
也可以使用 iptables<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考: <a href="https://zh.wikipedia.org/wiki/Netfilter">维基百科 Netfilter</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>参考: <a href="https://zh.wikipedia.org/wiki/Iptables">维基百科 Iptables</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>在 Netfilter 项目官网主页指出: <em>nftables is the successor of iptables</em> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>参考: <a href="https://en.wikipedia.org/wiki/Uncomplicated_Firewalld">维基百科 Uncomplicated Firewall</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>参考: <a href="https://en.wikipedia.org/wiki/Firewalld">维基百科 Firewalld</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>局部加权回归</title>
    <url>/2021/10/30/locally-weighted-regression/</url>
    <content><![CDATA[<p>简单介绍局部加权回归算法的思想</p>
<span id="more"></span>
<h2 id="基本思想">基本思想</h2>
<p>文章<a href="/2021/10/26/underfitting-and-overfitting/" title="欠拟合与过拟合">欠拟合与过拟合</a>简单介绍了欠拟合与过拟合的相关概念，
其中我们可以发现，如果选择的模型的阶比较低，就可能出现欠拟合的情况，
但如果过高，则又会出现过拟合的情况。</p>
<p>因此，局部加权回归的思想就是，只关注<strong>在预测点附近</strong>的样本点，
忽略或者减小离预测点较远的样本的影响。</p>
<p>如果把样本局限在预测点的附近，就可以将这些样本点<strong>近似</strong>看做是线性的
（这有点像微分的概念），这样就可以使用线性模型进行拟合，而无需考虑模型的阶。</p>
<h2 id="数学原理">数学原理</h2>
<h3 id="引入权值">引入权值</h3>
<p>在这个算法中，
我们设<strong>假设函数（hypotheses）</strong>：
$
\sum_{i=1}^{m} w^{i} ( y^{i} - \theta^{T} x^{i} )^{2}
$。
其中$ w^{i} $为权值，且有<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<p>$$
w^{i} = \exp{(- \frac {1} {2} ( x^{(i)} - x )^{2} )}
$$</p>
<p>这里将$ e^{x} $记作$ \exp{(x)} $，$ e $为<strong>自然常数</strong>。$ x $指需要进行预测的位置，可看作是$ x $轴上的一个坐标点。</p>
<p>$ w^{i} $是一个钟形曲线，比如
$
e^{- \frac{1}{2} (x - 1)^{2}}
$
的函数图像为：<img src="Figure_1.svg" alt="&quot;Figure 1&quot;" title="Figure 1" loading="lazy" /></p>
<p>容易看出来：
若$ \mid x^{(i)} - x \mid $越小，则有$ w^{i} \approx 1 $，
若$ \mid x^{(i)} - x \mid $越大，则有$ w^{i} \approx 0 $。</p>
<p>在示例的函数中则表现为：离$ x = 1 $越近，它的权值越大，越远则权值越小，
于是，离$ x = 1 $近的点得到重视，而离$ x $较远的点的影响被降低。</p>
<h3 id="一般化">一般化</h3>
<p>将权值函数写成更一般的方式：</p>
<p>$$
w^{i} = \exp{(- \frac {( x^{(i)} - x )^{2}} {2 \tau^{2}})}
$$</p>
<p>其中$ \tau $被称为<strong>波长函数</strong>，它能够控制权值随距离下降的速度。
下图是一个例子：<img src="Figure_2.svg" alt="Figure 2" title="Figure 2" loading="lazy" /></p>
<p><em>上图中的$ t $代表$ \tau $</em></p>
<h2 id="需要注意的问题">需要注意的问题</h2>
<p>首先，需要明确指出，局部加权回归<strong>不能完全避免</strong>欠拟合与过拟合的问题，
原因在于，算法实际上还是在使用线性回归，如果权值随距离下降的速度很慢，
即$ \tau $很大，算法实际上仍受到大部分数据的影响，
但总体上看来，它仍比普通的线性回归更能避免欠拟合与过拟合的问题。</p>
<p>其次，算法实际上<strong>并没有</strong>建立一个永久模型。
换句话说，每一次预测，算法都需要重新遍历训练集，
然后才进行<strong>加权</strong>计算，最后给出预测。
这与普通的线性回归不同，在线性回归中，我们得出了$ \theta $，
实际上就得出了一个能用来预测的模型，无须在每次预测时又重新进行训练。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在<a href="/2021/09/11/linear-regression/" title="线性回归">线性回归</a>一文中提到，
$ \theta $也被称为权值，但注意，这两者是不同的。$ \theta $指的是输入特征的权值，
而$ w^{i} $指的是训练集中不同样本的权值，
而选择这个函数的理由是：根据经验，它具有普遍性（<s>概率论的奇妙之处</s>）。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回归算法</tag>
        <tag>算法优化</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/2021/11/25/logistic-regression/</url>
    <content><![CDATA[<p>逻辑回归是不同于线性回归的另一种机器学习的算法</p>
<span id="more"></span>
<h2 id="线性回归的不足">线性回归的不足</h2>
<p>当数据的分布情况是这样子的时候，
线性回归得出的模型效果不好：
<img src="Figure_1.svg" alt="&quot;Figure 1&quot;" title="Figure 1" loading="lazy" /></p>
<p>于是我们希望有数学模型能够描述这种关系，
这个函数模型即：$ h(x) = \frac{1}{1 + e^{- \theta^{T} x}} $<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="数学原理">数学原理</h2>
<h3 id="概率函数">概率函数</h3>
<p>设$ h*{\theta}(x) = \frac{1}{1 + e^{- \theta^{T} x}} $，
$ P(y = 1 \mid x ; \theta) = h*{\theta}(x) $，
$ P(y = 0 \mid x ; \theta) = 1 - h_{\theta}(x) $，
当$ y \in {0, 1} $时，我们可以这样子优化一下：</p>
<p>$$
P(y \mid x; \theta) = h_{\theta}(x)^{y} (1 - h_{\theta}(x))^{1 - y}
$$</p>
<p>当$ y = 1 $时，$ P(y \mid x; \theta) = h_{\theta}(x) $，即$ y = 1 $的概率。</p>
<p>当$ y = 0 $时，$ P(y \mid x; \theta) = 1 - h_{\theta}(x) $，即$ y = 0 $的概率。</p>
<p>优雅！</p>
<h3 id="进行极大似然估计">进行极大似然估计</h3>
<p>设似然函数：</p>
<p>$$
L(\theta) = \prod_{i=1}^{m} P(y^{(i)} \mid x^{(i)}; \theta)
$$</p>
<p>$$
l(\theta) = \frac{\partial}{\partial \theta} L(\theta)
$$</p>
<p>可得：</p>
<p>$$
\frac{\partial}{\partial \theta_{j}} l(\theta) =
\sum_{i=1}^{m} (y^{(i)} - h_{\theta}(x^{(i)})) x_{j}^{(i)}
$$</p>
<h3 id="梯度上升求解">梯度上升求解</h3>
<p>类似梯度下降，当函数具有最大值时，
使随机选取的点$ x{0} $进行如下更新<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<p>$$
x_{1} = x_{0} + \alpha \frac{\mathrm d}{\mathrm dx}f(x_{0})
$$</p>
<p>即可得到：</p>
<p>$$
\theta_{j} = \theta_{j} +
\partial \sum_{i=1}^{m} {(y^{(i)} - h_{\theta} (x^{(i)}))} x_{j}^{(i)}
$$</p>
<h2 id="与线性回归的对比">与线性回归的对比</h2>
<p>最后推导得出的公式与线性回归的推导公式十分相似，
但实际上$ h_{\theta}(x) $表示的函数不再是线性的，
因此，逻辑回归与线性回归实际上是不相同的。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>别问为什么，问就是经验公式。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>详情见文章<a href="/2021/09/16/gradient-descent/" title="梯度下降算法">梯度下降算法</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>编程魔法学</title>
    <url>/2023/07/05/magic-algorithms/</url>
    <content><![CDATA[<p>在这篇文章中记录一些奇奇怪怪的编程技巧。可能的话，会基于自己的理解进行一些解释。</p>
<span id="more"></span>
<h2 id="计算数据中比特1的数量">计算数据中比特1的数量</h2>
<p>在数据中比特<code>1</code>的数量也称为数据的汉明权重<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>在这里我们探讨一下<strong>计算32位数据的汉明权重</strong>。</p>
<h3 id="从零开始">从零开始</h3>
<p>虽然叫从零开始，但如果数据为“0”，那我们也没有问题可以解决。
从“1”开始呢？假设数据只有1比特位，那我们直接使用“瞪眼法”，
根据“显然理论”，能够直接得出答案，也没有问题需要解决了。</p>
<p>于是我们从2个比特位的数据出发。由于只有两位，我们可以轻松地列出所有可能。</p>
<table>
<thead>
<tr>
<th style="text-align:left">x</th>
<th style="text-align:left">汉明权重</th>
<th style="text-align:left">汉明权重二进制表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00B</td>
<td style="text-align:left">0</td>
<td style="text-align:left">00B</td>
</tr>
<tr>
<td style="text-align:left">01B</td>
<td style="text-align:left">1</td>
<td style="text-align:left">01B</td>
</tr>
<tr>
<td style="text-align:left">10B</td>
<td style="text-align:left">1</td>
<td style="text-align:left">01B</td>
</tr>
<tr>
<td style="text-align:left">11B</td>
<td style="text-align:left">2</td>
<td style="text-align:left">10B</td>
</tr>
</tbody>
</table>
<p>我们可以发现，对于2个比特位而言，其汉明权重可以由它2个比特位的高位和低位相加，
结果就是其对应的汉明权重。我们可以这样实现：</p>
<pre><code class="language-c">// 假设n表示汉明权重，x为2比特位的数据
n = x + (x &gt;&gt; 1);
</code></pre>
<h3 id="逐步前进">逐步前进</h3>
<p>现在，我们将其拓展至4个比特位。
<strong>但让我们先约定好</strong>：</p>
<ul>
<li>对于处于高位的两个比特位，在此后我们简称为“<strong>高位</strong>”。</li>
<li>与之对应的，处于低2位的两个比特位，我们称为“<strong>低位</strong>”。</li>
<li>4比特位的数据，相对与2比特位数据来说，是“<strong>高位数据</strong>”，因为它具有更多的比特位。</li>
<li>自然而然地，2比特位数据相对于4比特位数据来说，就是“<strong>低位数据</strong>”。</li>
</ul>
<p>有一个问题，当我们将其扩展时，如扩展到4位<code>b3 b2 b1 b0</code>，
我们进行移位时，<code>b2</code>会被移入原先的<code>b1 b0</code>所在的两位数据中，
这破坏了两个数据的独立性，我们应当避免。</p>
<p>我们知道移位运算符会使用<code>0</code>填充空缺位，因此我们可以使<code>b2</code>恒为<code>0</code>，
这样即使它被移入了下个数据中，也不会对问题造成影响，
我们可以使用<code>&amp;</code>运算符轻松地解决这个问题：</p>
<pre><code class="language-c">// 我们将4位数据x视为2个2位数据x1与x2，并将每个2位数据的最低位置0
y = (x &amp; 0b1010) &gt;&gt; 1;
// 此时z还并不是x的汉明权重
z = x + y;
</code></pre>
<p>在经过上面的计算后，z在高位和低位分别保存了对应2比特位数据的汉明权重。
现在我们将它们相加：</p>
<pre><code class="language-c">// 我们将z视为4位数据，并获取低2位
tmp = z &amp; 0b0011;
// 低2位与高2位相加，由于右移会将低2位数据丢弃，我们现在可以忽略它
n = tmp + (z &gt;&gt; 2);
</code></pre>
<p>写成一行则是：</p>
<pre><code class="language-c">n = (z &amp; 0b0011) + (z &gt;&gt; 2);
</code></pre>
<p>似乎很熟悉？让我们将其整理一下：</p>
<pre><code class="language-c">// 假设x为2比特位的数据
nx = x + (x &gt;&gt; 1);
// 或者我们写复杂一点
nx = (x &amp; 0b01) + ((x &amp; 0b10) &gt;&gt; 1); // 注意两次与的掩码不同

// 假设y为4比特位的数据，同样地我们稍微写得复杂一些
// 此时我们不再忽略低位数据，因为它可能会被移入下一个数据
z = (y &amp; 0b0101) + ((y &amp; 0b1010) &gt;&gt; 1);
nz = (z &amp; 0b0011) + ((z &amp; 0b1100) &gt;&gt; 2);
</code></pre>
<p>在计算<code>x</code>的汉明权重时，我们使用<code>&amp;</code>运算符与掩码<code>0b10</code>提取出高位，并将其与低位相加。</p>
<p>我们再看看生成<code>z</code>的过程，我们先是使用<code>&amp;</code>运算符与掩码<code>0b1010</code>提取出两个低位数据的高位，
并将其与各自的低位相加。这实际上与计算<code>x</code>的汉明权重的过程是等价的，
只不过在这里同时进行了两次计算。</p>
<p>我们在看看计算<code>z</code>的汉明权重：用<code>&amp;</code>运算符与掩码<code>0b1100</code>提取出高位，并与低位相加。</p>
<p>这与计算<code>x</code>的汉明权重几乎是一模一样：<strong>提取高位，并与低位相加，结果存储在低位</strong>，
唯一的区别就是我们从2比特位提升到了4比特位！</p>
<h3 id="向更高位拓展">向更高位拓展</h3>
<p>我们正在向更高位前进，于是我们的约定也会相应地改变。</p>
<p>经过前两步的分析，我们可以做出这样的推断：对于一个8比特位，也就是一个字节的数据，
我们能够通过这样子得到它的汉明权重：</p>
<pre><code class="language-c">// x为一字节的数据
y = (x &amp; 0b01010101) + ((x &amp; 0b10101010) &gt;&gt; 1); // x对应的4个数据的汉明权重：y3 y2 y1 y0
z = (y &amp; 0b00110011) + ((y &amp; 0b11001100) &gt;&gt; 2); // z1 = y3 + y2, z0 = y1 + y0
n = (z &amp; 0x00001111) + ((z &amp; 0b11110000) &gt;&gt; 4); // n = z1 + z0
</code></pre>
<p>在上述例子中，<code>x</code>为一字节的数据，将其视为4个2比特位的数据，
并进行我们的计算：<strong>提取高位，与低位相加，并将结果存储在低位</strong>。
得到的<code>y</code>则存储了<code>x</code>中4个数据对应的汉明权重，此时再将<code>y</code>视为2个4比特位的数据，
重复我们的计算。
随后得到<code>z</code>，在<code>z</code>中存储了<code>y</code>中的2个数据对应的汉明权重，我们再一次地进行计算。
最后我们得到了原始数据<code>x</code>的汉明权重。
将上述的代码写成十六进制后：</p>
<pre><code class="language-c">// 此处x为一字节的任意数据
char x = 0xAB;
char y = (x &amp; 0x55) + ((x &amp; (0xAA)) &gt;&gt; 1);
char z = (y &amp; 0x33) + ((y &amp; (0xCC)) &gt;&gt; 2);
char n = (z &amp; 0x0F) + ((z &amp; (0xF0)) &gt;&gt; 4);

// 或者
char x = 0xAB;
char y = (x &amp; 0x55) + ((x &amp; (~0x55)) &gt;&gt; 1);
char z = (y &amp; 0x33) + ((y &amp; (~0x33)) &gt;&gt; 2);
char n = (z &amp; 0x0F) + ((z &amp; (~0x0F)) &gt;&gt; 4);
</code></pre>
<p>这样子我们就得到了计算一字节数据的汉明权重的方法。</p>
<h3 id="总结规律">总结规律</h3>
<p>在之前我们逐步分析的向高位拓展的过程，
实际上是逐渐从低到高的方向，计算汉明权重。
得出的汉明权重实际上保存在新的数据上了。
我们之后所做，其实只是将这些结果相加。
于是我们能得出这样子的规律：</p>
<pre><code>x7  x6  x5  x4  x3  x2  x1  x0  x
|   |   |   |   |   |   |   |
+---+   +---+   +---+   +---+
  |       |       |       |
  y3      y2      y1      y0    y
  |       |       |       |
  +-------+       +-------+
      |               |
      z1              z0        z
      |               |
      +---------------+
              |
              n
</code></pre>
<p>这是一个8比特位数据的汉明权重计算过程。
对于<code>x</code>来说，它可以看作4个2比特位的数据，
这4个数据的汉明权重存储在了<code>y</code>中，<code>y</code>又被视作2个4比特位的数据。
之后我们将其逐渐相加，最终得出原始数据的汉明权重。
对于更高位来说，只不过是将这颗树向上拓展而已，
于是我们可以直接得出32位数据的汉明权重计算函数：</p>
<pre><code class="language-c">#define MASK_1  0x55555555
#define MASK_2  0x33333333
#define MASK_4  0x0F0F0F0F
#define MASK_8  0x00FF00FF
#define MASK_16 0x0000FFFF

unsigned int ones(unsigned int x) &#123;
    x = (x &amp; MASK_1) + ((x &amp; (~MASK_1)) &gt;&gt; 1);
    x = (x &amp; MASK_2) + ((x &amp; (~MASK_2)) &gt;&gt; 2);
    x = (x &amp; MASK_4) + ((x &amp; (~MASK_4)) &gt;&gt; 4);
    x = (x &amp; MASK_8) + ((x &amp; (~MASK_8)) &gt;&gt; 8);
    x = (x &amp; MASK_16) + ((x &amp; (~MASK_16)) &gt;&gt; 16);
    return (unsigned int)x;
&#125;
</code></pre>
<p>上面给出的示例函数已经能够胜任计算“1”这项工作了。</p>
<h3 id="优化">优化</h3>
<h4 id="优化取反操作">优化取反操作</h4>
<p>在之前我们提到，处于高位的比特位可能会被移入低位，因此需要将其置为<code>0</code>。
但实际上，我们还可以换一种思维方式：等到它被移入下一位数据后，我们再忽略它。
于是我们能够得出这样子的方法：</p>
<pre><code class="language-c">#define MASK 0x55555555
x = (x &amp; MASK) + ((x &gt;&gt; 1) &amp; MASK);
</code></pre>
<p>代码似乎没有太大变化，但实际上，这使得我们无需使用<code>~</code>运算符对掩码进行取反，
节省了一点宝贵的时间。</p>
<h4 id="特殊优化">特殊优化</h4>
<p>我们接着进行优化。</p>
<p>现在让我们回到最初对于2比特位数据的探讨中，现在我们再将穷举的表格列出来。
不过这次我们只列出二进制格式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">x</th>
<th style="text-align:left">汉明权重</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
</tr>
<tr>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">10</td>
</tr>
</tbody>
</table>
<p>我们再看看2比特位的二进制减法的表格，这里我们只列出需要用到的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
<th style="text-align:left">a - b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
</tr>
<tr>
<td style="text-align:left">01</td>
<td style="text-align:left">00</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">01</td>
<td style="text-align:left">10</td>
</tr>
</tbody>
</table>
<p>我们发现什么？倘若我们将<code>a</code>视为数据<code>x</code>，而<code>b</code>视为右移一位之后的数据，
那么<code>a - b</code>的结果将直接是数据<code>x</code>的汉明权重！
于是就有一个针对2比特位数据的特殊优化：</p>
<pre><code class="language-c">#define MASK 0x55555555
x = x - ((x &gt;&gt; 1) &amp; MASK);
</code></pre>
<p>这使得我们直接省掉了一次<code>&amp;</code>操作，再一次节省了一点宝贵的时间。
不同于第一个优化，这个优化无法拓展到更高位。
举个简单的例子：对于4比特位的数据<code>a = 0b0100</code>，它的汉明权重是<code>1</code>。
接下来它会进行右移两位的操作，于是有<code>b = 0b0001</code>，
那么<code>a - b = 0b0011</code>，对应十进制数<code>3</code>，显然不正确。</p>
<h4 id="优化加法">优化加法</h4>
<p>接下来我们思考一个问题：
我们现在是用<code>&amp;</code>操作，忽略掉我们不需要的比特位，借此来保证后续的加法能够得出正确的结果。
但当高位或者低位全是0时，在我们进行加法操作后，这些比特位会保持不变。
换句话说，它不产生进位，于是我们可以把忽略它的时机推迟到加法之后。</p>
<p>那我们能够在那些情况下忽略掉<code>&amp;</code>操作呢？
答案是：进行加法后，产生的进位不会越过高位和低位“分界线”。</p>
<p>让我们慢慢进行分析：</p>
<pre><code class="language-c">int x = 0xFFFFFFFF;
// 此时x视为16个2比特位
x -= (x &gt;&gt; 1) &amp; 0x55555555;
// 此时x视为8个4比特位
printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0xAAAAAAAA
</code></pre>
<p>此时x的二进制格式：<code>10'10 ...</code>（<code>'</code>只是用作分隔，便于观察），
显然，此时x的高位与低位相加会越界：<code>10b + 10b = 01'00b</code>
因此我们不对它进行优化：</p>
<pre><code class="language-c">printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0xAAAAAAAA
// 此时x视为8个4比特位
x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);
// 此时x视为4个8比特位
printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x44444444
</code></pre>
<p>经过上面的计算后，此时x的二进制格式：<code>0100'0100 ...</code>，高位与低位相加，不会产生越界。</p>
<p>那存在产生越界可能性吗？让我们看看当<code>x</code>视为4个8比特位数据时怎样才会越界：
<code>1000b + 1000b = 10000b</code>，也就是说当汉明权重满足<code>max(高位，低位) &gt;= 8</code>时才可能发生越界。
而此时，我们拥有的比特位也才只有8个，不可能从更低比特位的数据中获得大于或等于8的汉明权重。
因此我们可以将<code>&amp;</code>操作推迟：</p>
<pre><code class="language-c">printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x44444444
// 此时x视为4个8比特位
x = (x + (x &gt;&gt; 4)) &amp; 0x0F0F0F0F;
// 此时x视为2个16比特位
printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08080808
</code></pre>
<p>我们再一次节省了一个<code>&amp;</code>操作。</p>
<h4 id="更高位的优化">更高位的优化</h4>
<p>现在到更高的位数看看，我们现在将<code>x</code>视为2个16比特位的数据，
每个数据的高位和低位是更低位数据的汉明权重。</p>
<p>在上一步优化中，我们注意到，<s>加法的力量，是有极限的</s>，我们在进行加法前进行<code>&amp;</code>操作，
实际上是避免存在因为进位而破坏数据的独立性，而我们现在以及拥有了16比特位的数据，
能够存储的最大数字远远超过了32位数据所能拥有的最大的汉明权重。
也就是说，我们或许可以忽略<strong>可能因为进位导致数据独立性被破坏</strong>这个问题。</p>
<p>那我们就分析一下，是否可以忽略加法后的<code>&amp;</code>操作：</p>
<pre><code class="language-c">printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08080808
// 此时x视为2个16比特位
x += x &gt;&gt; 8;
// 此时x视为1个32为比特位
printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08100810
</code></pre>
<p>我们发现，结果虽然发生了进位，但进位仍处于低位，而没有发生越界。
并且，此时我们存储汉明权重的比特位是16个比特位数据的低8位，
显然足够我们容纳所有求和的结果。那我们继续：</p>
<pre><code class="language-c">printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08100810
// 此时x视为1个32为比特位
x += x &gt;&gt; 16;
// 此时x的最低8位存储的就是汉明权重
printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08101020
</code></pre>
<p>现在，我们能够发现：实际上存储汉明权重的只有低8位（实际上只有6比特位，但这样子看着比较方便），
其余位的均可忽略。那我们可以得知，当我们在将低8位作为存储结果的位置，
也就是我们将32位数据视为2个16位数据时，我们就可以不进行<code>&amp;</code>操作了。</p>
<p>为什么是16位数据呢？因为在我们将其视作16位数据时，会进行这样的操作：
<code>x &gt;&gt; 8</code>，这实际上就是把结果存入低8位，并将整个16位数据视为了一个整体。
即使是更高位数据，我们求和的结果也不会超过这8个比特位。</p>
<blockquote>
<p>题外话，实际上这还能够拓展到64位数据，我们只需要加多一行：</p>
<pre><code class="language-c">x += x &gt;&gt; 32;
</code></pre>
<p>即可。当然，前面出现的掩码也需要相应地拓展到64位。</p>
</blockquote>
<p>最后我们可以这样子得到结果：</p>
<pre><code class="language-c">printf(&quot;x = 0x%08X\n&quot;, x);  // x = 0x08101020
unsigned int n = x &amp; 0xFF;
// 或者
unsigned int n = x &amp; 0x3f;
</code></pre>
<h3 id="最终结果">最终结果</h3>
<p>我们现在将上述的优化都写下来：</p>
<pre><code class="language-c">unsigned int ones(unsigned int x) &#123;
    x -= (x &gt;&gt; 1) &amp; 0x55555555;
    x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);
    x = (x + (x &gt;&gt; 4)) &amp; 0x0F0F0F0F;
    x += x &gt;&gt; 8;
    x += x &gt;&gt; 16;
    rerurn x &amp; 0xFF;
&#125;
</code></pre>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E6%9D%83%E9%87%8D">Wikipedia</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>将init.vim迁移至init.lua</title>
    <url>/2023/01/12/migrate-init-vim-to-init-lua-for-neovim/</url>
    <content><![CDATA[<p>本文是根据neovim手册写的一些笔记，是我在迁移时遇到的一些问题，记录下来方便回顾。
详细的内容可在nvim中使用命令<code>:help lua-guide</code>进行查看。</p>
<span id="more"></span>
<h2 id="迁移变量">迁移变量</h2>
<blockquote>
<p>参考手册 <code>:help lua-guide-variables</code></p>
</blockquote>
<p>首先的第一种类型变量，使用<code>let</code>指令赋值，一般可被分为以下几种：</p>
<ul>
<li>全局变量（Global)，在vim中以<code>g:</code>开头</li>
<li>缓存区变量（Buffer-socped），在vim中以<code>b:</code>开头</li>
<li>窗口变量（window-socped），在vim中以<code>w:</code>开头</li>
<li>标签页变量（tabpage-socped），在vim中以<code>t:</code>开头</li>
<li>普通变量，在vim中以<code>v:</code>开头</li>
<li>环境变量，如<code>$HOME</code></li>
</ul>
<p>在lua中可以使用vim模块轻松的访问或设置这些变量。
如<code>let g:airline_theme='owo'</code>，在lua中可以这样设定<code>vim.g.airline_theme='owo'</code>，
类似的，可以使用<code>vim.b.foo</code>、<code>vim.w.foo</code>、<code>vim.t.foo</code>、<code>vim.v.foo</code>、<code>foo.env</code>
对其他类型的变量进行访问与设置。
没有前缀的变量应该在<code>vim.g</code>中。</p>
<blockquote>
<p>参考手册 <code>:help lua-guide-options</code></p>
</blockquote>
<p>还有一种类型的变量，说是变量，但实际上是vim内置的选项，
在vim中使用<code>set</code>相关的指令进行设置。</p>
<p>在lua中，使用<code>vim.o</code>、<code>vim.go</code>、<code>vim.bo</code>、<code>vim.wo</code>对这些变量进行访问与设置。
在我的迁移过程中使用的比较少，请参考手册。</p>
<h2 id="迁移按键映射">迁移按键映射</h2>
<blockquote>
<p>参考手册<code>:help lua-guide-mappings</code></p>
</blockquote>
<p>在lua中使用<code>vim.keymap.set()</code>函数进行映射，详细请参考手册。</p>
<p>在迁移coc.nvim插件时，由于coc的Github主页上的README中写的配置没有更新<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，
于是要自己去看手册找函数什么的。有一个例子是在init.vim的配置中，
有个<code>coc#pum#visable()</code>函数，新的调用方式是<code>pumvisable()</code>这样子的。
而在lua中则应该这样子调用：<code>vim.fn.pumvisable()</code>，
并且这个函数的返回值似乎返回的是数字，因此在vim中的配置</p>
<pre><code class="language-vim">inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;
    \ pumvisable() ? &quot;\&lt;C-n&gt;&quot; :
    \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :
    \ coc#refresh()
</code></pre>
<p>在lua中则可以这样子配置</p>
<pre><code class="language-lua">local opts = &#123;silent = true, noremap = true, expr = true&#125;
vim.keymap.set(&quot;i&quot;, &quot;&lt;TAB&gt;&quot;, &quot;pumvisable() ? '\&lt;C-n&gt;' : &lt;SID&gt;check_back_space() ? '\&lt;TAB&gt;' : coc#refresh()&quot;, opts)
-- 这个实际上是直接使用了vim的配置，大部分的配置都可以像这样子进行迁移

-- 但我喜欢直接使用lua函数，就像下面这样
vim.keymap.set(&quot;i&quot;, &quot;&lt;TAB&gt;&quot;, function()
    if vim.fn.pumvisable() == 1 then
        return &quot;&lt;C-n&gt;&quot;
    elseif check_back_space() then
        return &quot;&lt;TAB&gt;&quot;
    end
end, opts)
</code></pre>
<p>这个例子可以在<code>:help coc-completion</code>中找到，用到的快捷键，如<code>&lt;C-n&gt;</code>，
可以在<code>:help coc-list-mappings</code>中找到</p>
<p>其实大部分的映射可以直接使用，剩下的需要修改的也基本与上述例子相同。</p>
<h2 id="迁移vim命令">迁移vim命令</h2>
<blockquote>
<p>参考手册<code>:help lua-guide-vim-commands</code></p>
</blockquote>
<p>vim命令是指在命令模式中使用的指令，就是跟在<code>:</code>后面的，比如<code>:highlight</code>、<code>:syntax</code>等，
这些指令可以通过<code>vim.cmd.highlight</code>、<code>vim.cmd.syntax</code>来访问。</p>
<p>但有个令人困惑的问题，在创建NERDTree的一个autocmd时，
有一个<code>silent NERDTreeMirror</code>的命令，
直接转换成<code>vim.cmd.silent(&quot;NERDTreeMirror&quot;)</code>会失败，
使用<code>vim.cmd(&quot;silent NERDTreeMirror&quot;)</code>则可以正常使用。</p>
<h2 id="迁移函数">迁移函数</h2>
<blockquote>
<p>参考手册<code>:help lua-guide-vim-functions</code></p>
</blockquote>
<p>函数的迁移比较复杂，请参考手册。</p>
<h2 id="迁移插件">迁移插件</h2>
<p>这里只记录如何在lua中使用<code>vim-plug</code>作为插件管理器。<br />
我使用的方法如下：</p>
<pre><code class="language-lua">vim.fn['plug#begin']()
vim.cmd(&quot;Plug 'example/plug'&quot;)  -- 注意Plug方法后面跟的插件需要带单引号`'`，
                                -- 因此外围函数使用双引号`&quot;`。
vim.fn['plug#end']()
</code></pre>
<p>实际上可以封装成一个函数，如<code>Plug('example/plug')</code>，
这样子看起来挺像原生的vim-plug的方法。owo</p>
<h2 id="其他">其他</h2>
<p>最后为了能格式化lua的配置文件，使用<a href="https://github.com/sumneko/lua-language-server">sumneko/lua-language-server</a>
作为LSP服务器，在参考了<a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers#lua">coc的配置例子</a>后，
使用的配置如下：</p>
<pre><code class="language-json">&#123;
  &quot;languageserver&quot;: &#123;
    &quot;lua&quot;: &#123;
      &quot;command&quot;: &quot;lua-language-server&quot;,
      &quot;args&quot;: [],
      &quot;filetypes&quot;: [&quot;lua&quot;]
    &#125;
  &#125;
&#125;
</code></pre>
<p><strong>注</strong>：我是从ArchLinux软件源中安装的，因此<code>lua-language-server</code>可直接调用 =w=</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>当时的时间是2023年1月12日 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>事记</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
        <tag>配置</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Neovim配置</title>
    <url>/2023/07/03/my-neovim-conf/</url>
    <content><![CDATA[<p>在这里记录一下我的nvim配置。</p>
<p>持续更新中…</p>
<span id="more"></span>
<h2 id="快捷键配置">快捷键配置</h2>
<p>按键符号采用nvim内的示例，如<code>A</code>表示<code>alt</code>、<code>C</code>表示<code>ctrl</code>、<code>&lt;CR&gt;</code>表示回车等。
详细内容参考<code>:help keycodes</code>。</p>
<h3 id="nvim快捷键">nvim快捷键</h3>
<p>这些是nvim自身的快捷键，而不是插件相关的快捷键。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;A-t&gt;</code></td>
<td style="text-align:left">关闭标签页</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>t</code></td>
<td style="text-align:left">下一个标签页</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;C-t&gt;</code></td>
<td style="text-align:left">新建标签页</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;S-t&gt;</code></td>
<td style="text-align:left">上一个标签页</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;C-j&gt;</code></td>
<td style="text-align:left">向上滚动，映射为<code>&lt;C-E&gt;&lt;C-E&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;C-k&gt;</code></td>
<td style="text-align:left">向下滚动，映射为<code>&lt;C-Y&gt;&lt;C-Y&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;TAB&gt;</code></td>
<td style="text-align:left">下/右窗口，映射为<code>&lt;C-W&gt;w</code></td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;S-TAB&gt;</code></td>
<td style="text-align:left">上/左窗口，映射为<code>&lt;C-W&gt;W</code></td>
</tr>
</tbody>
</table>
<h3 id="gitsigns快捷键">gitsigns快捷键</h3>
<p>gitsigns是在文件内对git记录进行快速操作的插件，
可以快速地重置、保存和查看更改记录<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>快捷键大部分在normal模式下使用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>]c</code></td>
<td style="text-align:left">下一个记录</td>
</tr>
<tr>
<td style="text-align:left"><code>[c</code></td>
<td style="text-align:left">上一个记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gsu</code></td>
<td style="text-align:left">撤销保存记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gss</code></td>
<td style="text-align:left">暂存记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gsr</code></td>
<td style="text-align:left">重置记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gsS</code></td>
<td style="text-align:left">暂存缓冲区所有记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gsR</code></td>
<td style="text-align:left">重置缓冲区所有记录</td>
</tr>
<tr>
<td style="text-align:left"><code>gsp</code></td>
<td style="text-align:left">预览修改</td>
</tr>
<tr>
<td style="text-align:left"><code>gsd</code></td>
<td style="text-align:left">相当于<code>git diff</code></td>
</tr>
<tr>
<td style="text-align:left"><code>gsD</code></td>
<td style="text-align:left">相当于<code>git diff HEAD</code></td>
</tr>
<tr>
<td style="text-align:left"><code>gst</code></td>
<td style="text-align:left">查看/隐藏删除的记录</td>
</tr>
</tbody>
</table>
<p>这个快捷键使用的模式比较特殊。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ox</td>
<td style="text-align:left"><code>gsc</code></td>
<td style="text-align:left">选择整个记录块（<strong>G</strong>it<strong>S</strong>aga <strong>S</strong>elect <strong>C</strong>hunk）</td>
</tr>
</tbody>
</table>
<h3 id="LSP快捷键">LSP快捷键</h3>
<p>LSP快捷键大部分处于normal模式。一些功能会使用到光标处的单词作为符号。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;el</code></td>
<td style="text-align:left">显示行诊断</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ec</code></td>
<td style="text-align:left">显示光标处诊断</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ea</code></td>
<td style="text-align:left">显示缓冲区诊断</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;fa</code></td>
<td style="text-align:left">格式化代码</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;rn</code></td>
<td style="text-align:left">符号重命名，可在visual模式使用</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;lr</code></td>
<td style="text-align:left">查看符号引用</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;li</code></td>
<td style="text-align:left">查看实现</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ol</code></td>
<td style="text-align:left">大纲</td>
</tr>
<tr>
<td style="text-align:left"><code>]e</code></td>
<td style="text-align:left">下一个问题诊断</td>
</tr>
<tr>
<td style="text-align:left"><code>[e</code></td>
<td style="text-align:left">上一个问题诊断</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;M-CR&gt;</code></td>
<td style="text-align:left">显示代码建议，可在visual模式使用</td>
</tr>
<tr>
<td style="text-align:left"><code>gc</code></td>
<td style="text-align:left">跳转到声明</td>
</tr>
<tr>
<td style="text-align:left"><code>gd</code></td>
<td style="text-align:left">跳转到定义</td>
</tr>
<tr>
<td style="text-align:left"><code>gt</code></td>
<td style="text-align:left">跳转到类型定义</td>
</tr>
<tr>
<td style="text-align:left"><code>K</code></td>
<td style="text-align:left">查看文档</td>
</tr>
</tbody>
</table>
<h4 id="Lspsaga快捷键">Lspsaga快捷键</h4>
<p>Lspsaga为neovim内置的LSP提供了更友好的界面，
因此在Lspsaga中配置的快捷键与LSP的基本相同，并会覆盖LSP的快捷键。
在这里列出Lspsaga专有的快捷键。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ls</code></td>
<td style="text-align:left">列出符号的所有定义、引用与实现</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;pd</code></td>
<td style="text-align:left">在悬浮窗口查看符号定义</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;pt</code></td>
<td style="text-align:left">在悬浮窗口查看类型定义</td>
</tr>
<tr>
<td style="text-align:left"><code>]E</code></td>
<td style="text-align:left">下一个错误（忽略警告）</td>
</tr>
<tr>
<td style="text-align:left"><code>[E</code></td>
<td style="text-align:left">上一个错误（忽略警告）</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ci</code></td>
<td style="text-align:left">列出所有调用符号的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;co</code></td>
<td style="text-align:left">列出符号调用的方法</td>
</tr>
</tbody>
</table>
<p>Lspsaga在预览窗口的快捷键有些混乱，大部分快捷键作用是相同的，
但有个别在不同类型的窗口<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>内不同，
加上个人习惯修改了部分按键，这里只列个大概。</p>
<ul>
<li><code>&lt;C-d&gt;</code>、<code>&lt;C-u&gt;</code>：窗口内容滚动。对应<code>down</code>和<code>up</code>的意思。</li>
<li><code>&lt;C-t&gt;</code>：跳出窗口。</li>
<li><code>q</code>、<code>&lt;ESC&gt;</code>、<code>&lt;C-c&gt;</code>：这些基本都有退出或取消操作的意思。</li>
<li><code>g</code>：这个大部分情况下是跳转。</li>
<li><code>o</code>：这个是展示预览或者编辑的意思，如果只是展示则不会跳转，此外还有打开折叠栏的意思。</li>
<li><code>&lt;CR&gt;</code>：表示执行、跳转等意思。</li>
<li><code>v</code>、<code>x</code>、<code>t</code>、<code>r</code>：这些都是新建窗口进行下一步操作。
分别对应<code>vsplit</code>、<code>split</code>、<code>tabedit</code>、<code>tabnew</code>。</li>
</ul>
<p><code>o</code>指令与<code>&lt;CR&gt;</code>有功能上的重复，但还是有一些区别。
如在大纲窗口中，<code>o</code>与<code>&lt;CR&gt;</code>都表现为在编辑区域打开并跳转到函数所在位置。
但在诊断窗口中，<code>o</code>被配置为展开折叠栏，而<code>&lt;CR&gt;</code>被配置为执行Code Action。</p>
<h3 id="Floaterm快捷键">Floaterm快捷键</h3>
<p>这是个悬浮终端的插件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nt</td>
<td style="text-align:left"><code>&lt;F12&gt;</code></td>
<td style="text-align:left">显示/隐藏悬浮终端</td>
</tr>
<tr>
<td style="text-align:left">nt</td>
<td style="text-align:left"><code>&lt;leader&gt;f12</code></td>
<td style="text-align:left">同上，但在没有Fn键的时候使用</td>
</tr>
</tbody>
</table>
<h3 id="nvim-tree快捷键">nvim-tree快捷键</h3>
<p>nvim-tree在自己的窗口中有自己的快捷键，使用<code>:help nvim-tree-mapping-default</code>查看。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">niv</td>
<td style="text-align:left"><code>&lt;F2&gt;</code></td>
<td style="text-align:left">打开/隐藏文件树</td>
</tr>
<tr>
<td style="text-align:left">niv</td>
<td style="text-align:left"><code>&lt;leader&gt;f2</code></td>
<td style="text-align:left">同上，但在没有Fn键的时候使用</td>
</tr>
</tbody>
</table>
<h3 id="Telescope快捷键">Telescope快捷键</h3>
<p>快捷键都处于normal模式使用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;F3&gt;</code></td>
<td style="text-align:left">查找文件，同时可用于关闭窗口</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;F3</code></td>
<td style="text-align:left">同上，但在没有Fn键的时候使用</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;clp</code></td>
<td style="text-align:left">查看register内容</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;ch</code></td>
<td style="text-align:left">查看历史命令</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;leader&gt;sh</code></td>
<td style="text-align:left">查看搜索历史</td>
</tr>
</tbody>
</table>
<h3 id="Nerdcommter快捷键">Nerdcommter快捷键</h3>
<p>用于快速注释。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">按键</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left"><code>&lt;leader&gt;ca</code></td>
<td style="text-align:left">切换注释风格，如C的<code>//</code>和<code>/* */</code></td>
</tr>
<tr>
<td style="text-align:left">nx</td>
<td style="text-align:left"><code>&lt;leader&gt;cc</code></td>
<td style="text-align:left">注释/取消注释</td>
</tr>
<tr>
<td style="text-align:left">nx</td>
<td style="text-align:left"><code>&lt;leader&gt;cs</code></td>
<td style="text-align:left">块注释</td>
</tr>
<tr>
<td style="text-align:left">nx</td>
<td style="text-align:left"><code>&lt;leader&gt;cu</code></td>
<td style="text-align:left">取消注释</td>
</tr>
</tbody>
</table>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在Git中，修改过的记录称为hunk，我习惯称为chunk。此外我还习惯称之为记录块，简称记录。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>指的是“定义预览”、“引用预览”、“实现预览”等窗口。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>neovim</tag>
        <tag>配置</tag>
        <tag>nvim</tag>
      </tags>
  </entry>
  <entry>
    <title>图册展示页</title>
    <url>/2023/07/17/post-for-gallery-layout-test/</url>
    <content><![CDATA[<p>用于展示一些图片，在Front matter区域中使用<code>photos</code>添加图片。</p>
<span id="more"></span>
<p>然而并不能在文章里面看到，可以用作封面用途。</p>
<p>可以添加多张，随机挑选。</p>
<p>这张图片
<img src="https://placehold.co/600x400" alt="600x400.jpg" loading="lazy" />
是从这里来的：<a href="https://placehold.co/600x400">https://placehold.co/600x400</a></p>
]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>相册</tag>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM 舵机控制</title>
    <url>/2021/03/18/pwm-servo/</url>
    <content><![CDATA[<p>介绍如何在树莓派上控制舵机（servo）</p>
<span id="more"></span>
<h3 id="PWM-基础知识">PWM 基础知识</h3>
<blockquote>
<p>PWM（Pulse Width Modulation）即脉宽调制，
是一种利用数字信号对模拟电路进行控制的一种方法。
详情自行搜索，<s>主要是我也不会</s>。</p>
</blockquote>
<h4 id="频率">频率</h4>
<p>指$ 1s $内，脉冲信号变化（高电平$ \to $低电平$ \to $高电平）的次数。</p>
<h4 id="周期">周期</h4>
<p>脉冲信号完成一次变化的时间称作一个周期。</p>
<h4 id="频率与周期的关系">频率与周期的关系</h4>
<p>$$
f = \frac{1}{T}
$$</p>
<p>一个周期为$ 20ms $脉冲信号，其频率为$ \frac{1}{20 \times 10^{-3}s} $，即$ 50Hz $。</p>
<h4 id="占空比">占空比</h4>
<p>在一个周期内，高电平持续的时间与整个周期的总时间的比例为占空比。
设整个周期的时间为$ T $，高电平持续的时间为$ t $，则占空比$ D $为：</p>
<p>$$
D = \frac{t}{T} \times 100\%
$$</p>
<p>或</p>
<p>$$
D = t \cdot f \times 100\%
$$</p>
<p>一个周期为$ 20ms $的脉冲信号，其中高电平持续时间为$ 1.5ms $，
则占空比为$ \frac{1.5ms}{20ms} \times 100\% = 7.5\% $。</p>
<h3 id="PWM-控制舵机">PWM 控制舵机</h3>
<p>使用 PWM 控制舵机时，一般使用频率为$ 50Hz $的 PWM 信号，
在$ 180^{\circ} $的舵机中，一般以$ 1.5ms $的高电平持续时间作为基准，
高电平持续时间$ 1.5ms\pm1ms $作分别为舵机旋转$ \mp90^{\circ} $的控制信号。</p>
<p>据此可得出相应的占空比，并通过设置 PWM 信号的占空比来控制舵机转动的角度。</p>
<table>
<thead>
<tr>
<th style="text-align:left">高电平持续时间</th>
<th style="text-align:left">占空比</th>
<th style="text-align:left">角度（顺时针为正）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$ 0.5ms $</td>
<td style="text-align:left">$2.5\%$</td>
<td style="text-align:left">$ +90^{\circ} $</td>
</tr>
<tr>
<td style="text-align:left">$ 1.5ms $</td>
<td style="text-align:left">$7.5\%$</td>
<td style="text-align:left">$ 0^{\circ} $</td>
</tr>
<tr>
<td style="text-align:left">$ 2.5ms $</td>
<td style="text-align:left">$12.5\%$</td>
<td style="text-align:left">$ -90^{\circ} $</td>
</tr>
</tbody>
</table>
<h3 id="使用-Python-实现-PWM-控制">使用 Python 实现 PWM 控制</h3>
<p>树莓派上的 GPIO 可实现 PWM，<s>虽然抖动很大</s>，
可以通过 Python 来对这些 GPIO 接口进行控制。</p>
<h4 id="使用-RPi-GPIO-库">使用 RPi.GPIO 库</h4>
<p>参考<a href="https://pypi.org/project/RPi.GPIO">PRi.GPIO PyPI</a>。</p>
<h5 id="导入-GPIO-包并初始化-GPIO-接口">导入 GPIO 包并初始化 GPIO 接口</h5>
<pre><code class="language-python">import RPi.GPIO as GPIO

# 使用编号 18 的 GPIO 接口
pin = 18

# 设置 GPIO 的编号模式，详情参考树莓派官网
GPIO.setmode(GPIO.BCM)

# 关闭奇奇怪怪的警告
GPIO.setwarnings(False)

# 初始化接口
GPIO.setup(pin, GPIO.OUT, initial=False)
</code></pre>
<h5 id="创建-PWM-实例">创建 PWM 实例</h5>
<pre><code class="language-python"># 创建实例
hz = 50
p = GPIO.PWM(pin, hz)

# 设置占空比
# 单位 ms
t = 1.5
# 乘以0.1,单位修正为 s，与 Hz 单位匹配
dc = t * hz * 0.1

# 启动 PWM
p.start(dc)

# 更改占空比
p.ChangeDutyCycle(dc)

# 停止 PWM
p.stop()

# 在程序结束时要释放对 GPIO 接口的控制
GPIO.cleanup()
</code></pre>
<h5 id="会产生的问题">会产生的问题</h5>
<p>正如前面所说，使用 PRi.GPIO 实现的 PWM 抖动很大，
因为这属于软件控制的 PWM，在频繁地更改占空比时会更明显，
在使用<code>p.ChangeDutyCycle(dc)</code>函数时也可能发生抖动，导致舵机不能转到指定角度。
在<code>p.start(dc)</code>后，即使没有任何操作，也仍可能发生抖动，
同时控制多个舵机时，不同接口还会产生干扰。</p>
<h5 id="解决方法">解决方法</h5>
<p>一种解决的方法是使用<code>time</code>模块中的<code>sleep()</code>函数进行延时。</p>
<pre><code class="language-python">p.start(dc)
sleep(0.5)
for i in range(0.5, 2.5 + 0.1, 0.1):
  dc = i * hz * 0.1
  p.ChangeDutyCycle(dc)
  sleep(0.5)
p.stop()
</code></pre>
<p>但这种方法并不能解决在空闲时出现的抖动，
也不能去除其他端口的干扰。</p>
<p>另一种方法则是在启动 PWM 后，进过延时就将其关闭。</p>
<pre><code class="language-python">p.start(dc)
sleep(0.5)
for i in range(0.5, 2.5 + 0.1, 0.1):
  dc = i * hz * 0.1
  p.start(dc)
  sleep(0.5)
  p.stop()
p.stop()
</code></pre>
<p>这种方法需要频繁的开启关闭 PWM，且仍不稳定，但在空闲时不会发生抖动。</p>
<p>还有一种方法：使用 pigpio 库。</p>
<h4 id="使用-pigpio">使用 pigpio</h4>
<p>使用 pigpio 库，可以实现硬件方式控制的 PWM，
能显著地提高 PWM 的抗干扰性。</p>
<p>参考 <a href="http://abyz.me.uk/rpi/pigpio/python.html">pigpio library</a></p>
<h5 id="启动服务">启动服务</h5>
<p>使用 pigpio 库需要启动 pigpiod 服务。</p>
<pre><code class="language-shell">sudo systemctl start pigpiod.service
</code></pre>
<h5 id="导入包并初始化">导入包并初始化</h5>
<pre><code class="language-python">import pigpio

# 使用编号 18 的接口
# 注意：使用接口的 BCM 编号
pin = 18

# 创建连接 pigpio 连接
pi = pigpio.pi()

# 设置 GPIO 接口输出模式
pi.set_mode(pin, pigpio.OUTPUT)
</code></pre>
<h5 id="PWM-设置">PWM 设置</h5>
<pre><code class="language-python"># 设置 PWM 频率为 50 Hz
pi.set_PWM_frequency(pin, 50)

# 设置 PWM 范围 0~100
# 与占空比相结合，范围 0~100
pi.set_PWM_range(pin, 100)

# 设置占空比设置为 25 即 25/100 = 1/4
pi.set_PWM_dutycycle(25)

# 关闭 PWM
pi.set_PWM_dutycycle(0)
</code></pre>
<h5 id="优缺点">优缺点</h5>
<p>使用 pigpio 时必须启动 pigpiod 服务，
但使用这个方式输出的 PWM 是硬件方式控制的，比较稳定，不易受到干扰。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Servo</tag>
        <tag>PWM</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派热点</title>
    <url>/2021/03/11/raspberrypi-access-point/</url>
    <content><![CDATA[<p>简单介绍如何在树莓派开启热点<br />
<em>参考自<a href="https://www.raspberrypi.org/documentation/computers/configuration.html#setting-up-a-routed-wireless-access-point">Setting up a routed wireless access point</a></em></p>
<span id="more"></span>
<p>需要的软件列表：</p>
<ul>
<li><code>hostapd</code>：用于开启热点</li>
<li><code>dnsmasq</code>：用于开启DHCP服务与DNS服务</li>
<li><code>iptables</code>：设置数据包转发规则</li>
<li><code>netfilter-persistent</code>：将 <code>iptables</code> 设置的规则持久化</li>
<li><code>iptables-persistent</code>：<code>netfilter-persistent</code> 插件</li>
</ul>
<h2 id="安装软件">安装软件</h2>
<p>运行命令</p>
<pre><code class="language-shell"># apt-get install hostapd dnsmasq iptables netfilter-persistent iptables-persistent
</code></pre>
<p>等待安装完成</p>
<h2 id="配置hostapd">配置hostapd</h2>
<p>编辑配置文件 <code>/etc/hostapd/hostapd.conf</code>，添加配置</p>
<pre><code class="language-conf"># 使用的网卡
interface=wlan0
# WiFi 名字
ssid=YOUR_WIFI_NAME
# 驱动
driver=nl80211
# WiFi 频率模式
hw_mode=g
# 信道
channel=7
# 是否 mac 过滤
macaddr_acl=0
# 认证算法
auth_algs=1
# 是否广播 SSID
ignore_broadcast_ssid=0
# 加密相关
wpa=2
wpa_passphrase=YOUR_WIFI_PASSWORD
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
</code></pre>
<p><strong>警告</strong>:
channel 不可随意选择，不同的国家与地区允许使用的信道不同</p>
<p>注：上面的配置启用的为 2.4GHz 的WiFi
如需使用 5GHz 的 WiFi，修改以下配置：</p>
<pre><code class="language-conf">#hw_mode=g
hw_mode=a
#channel=7
# 在内核启 CONFIG_ACS 编译选项后
# 该选项设置为 0 时会自动选择信道
# 树莓派似乎不支持......
channel=149
</code></pre>
<h2 id="配置dhcpcd">配置dhcpcd</h2>
<p>编辑配置文件 <code>/etc/dhcpcd.conf</code>，添加配置</p>
<pre><code class="language-conf"># 网卡
interface=wlan0
# 网卡地址
static ip_address=192.168.10.1/24
# 不要执行这个脚本
nohook wpa_supplicant
</code></pre>
<h2 id="配置dnsmasq">配置dnsmasq</h2>
<p>编辑配置文件 <code>/etc/dnsmasp.conf</code></p>
<pre><code class="language-conf"># 为这个网卡开启服务
interface=wlan0
# 不要在这个网卡开启服务
no-dhcp-interface=eth0
# 本机域
domain=wlan
# IP 地址分配范围
dhcp-range=192.168.10.1,192.168.10.20,255.255.255.0,24h
</code></pre>
<h2 id="设置数据包转发">设置数据包转发</h2>
<ol>
<li>
<p>允许包转发<br />
编辑配置文件 <code>/etc/sysctl.conf</code><br />
将 <code>net.ipv4.ip_forward=1</code> 取消注释</p>
</li>
<li>
<p>设置转发规则
运行命令</p>
<pre><code class="language-shell"># iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
</li>
<li>
<p>保存规则
运行命令</p>
<pre><code class="language-shell"># netfilter-persistent save
</code></pre>
</li>
</ol>
<h2 id="设置systemd启动服务">设置systemd启动服务</h2>
<p>启用 <code>hostapd.service</code>，<code>dnsmasq.service</code>，<code>netfilter-persistent.service</code><br />
禁用 <code>wpa_supplicant.service</code></p>
<pre><code class="language-shell"># systemctl unmask hostapd.service
# systemctl enable hostapd.service dnsmasq.service netfilter-persistent.service
# systemctl disable wpa_supplicant
</code></pre>
<h2 id="重启">重启</h2>
<p>设置完成后重启</p>
<pre><code class="language-shell"># reboot
</code></pre>
<p>不出意外，就能在 WiFi 列表里找到树莓派开启的 WiFi 了</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf">hostapd.conf 设置说明</a><br />
<a href="https://en.wikipedia.org/wiki/List_of_WLAN_channels">维基百科：WLAN channel</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>hostapd</tag>
        <tag>dnsmasq</tag>
        <tag>Access Point</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树</title>
    <url>/2024/01/21/scapegoat-tree/</url>
    <content><![CDATA[<p>简单介绍一下替罪羊树算法，以及代码实现。</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>偶然听说了替罪羊树，在看了几篇文章后发现似懂非懂，就自己上手边写边尝试理解。
写出来的代码虽然能跑，看着结果似乎也是对的，但因为是边学边写的，
也不能保证代码是对的，有错再更新。</p>
<p>参考：</p>
<ul>
<li><a href="https://oi-wiki.org/ds/sgt/">替罪羊树 - OI Wiki</a></li>
<li><a href="https://www.luogu.com.cn/blog/12755/ti-zui-yang-shu-jiang-yi">替罪羊树讲义 - 洛谷博客</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scapegoat_tree">Scapegoat tree - Wikipedia</a></li>
</ul>
<h2 id="什么是替罪羊树">什么是替罪羊树</h2>
<p>简单来说，替罪羊树是平衡二叉树的一种，但又不是严格意义上的平衡二叉树，
因为它允许不平衡的结点存在，
只在必要的时候会处理不平衡的结点（后面会提到什么时候处理）。
它处理不平衡的方式很简单：
将以不平衡结点为根的树中序展开，再将这个中序序列反序列化为树，
这个过程称为<strong>重构</strong>。
此外，它的删除操作也非常简单：将结点标记为<em>已删除</em>即可，也就是逻辑删除。
只有在重构时才会真正移除标记为<em>已删除</em>的结点。</p>
<blockquote>
<p>这里还有一些细节问题，不过等到后面在详细解释吧。=w=</p>
</blockquote>
<h2 id="替罪羊树的代码定义">替罪羊树的代码定义</h2>
<h3 id="一些变量定义">一些变量定义</h3>
<p>在我的代码实现里，我使用数组形式构造替罪羊树，
并且数组下标<strong>将从<code>1</code>开始，而不是<code>0</code></strong>。</p>
<p>首先是一些辅助用的定义：</p>
<pre><code class="language-c">// 最大结点数
#define MAXN 1024
// 记录插入的结点数量
int count = 0;
// alpha
double alpha = 0.75;
</code></pre>
<p>这些变量的含义在后文会解释，现在就只需要知道它们的存在就行了。=w=</p>
<p>接下来是树结构定义：</p>
<pre><code class="language-c">// 结点值
int v[MAXN] = &#123;0&#125;;
// 结点权值，定义为结点的重复次数。
int w[MAXN] = &#123;0&#125;;
// 结点的左右子树索引，&quot;left(right) tree&quot;取首字母
int lt[MAXN] = &#123;0&#125;;
int rt[MAXN] = &#123;0&#125;;
</code></pre>
<p>树以数组的形式表达，
<strong>树结点</strong>（在之后简称结点）按照插入顺序编号，
结点并不真实存在，能用于表示结点的只有它的编号，
我将这个编号称为<strong>结点索引</strong>（在之后简称为索引）。</p>
<p>在<code>lt</code>和<code>rt</code>数组中存储的就是索引。
若<code>lt[k]==i</code>，这表明<strong>索引为k</strong>的结点，其左子树的<strong>索引为i</strong>。
根结点的索引则由调用方负责保存。</p>
<p>数组<code>v</code>负责保存结点值（value）。</p>
<p>需要额外解释的是<code>w</code>数组，这是由<code>weight</code>取首字母而来。
在具体的代码实现中，如果数据出现重复，这些重复的数据只会存储在一个结点上。
若<code>w[k] == 2</code>则表明数据<code>v[k]</code>出现了两次，从树的逻辑结构上来看，
这个结点只出现了一次。
若<code>w[k] == 0</code>则表明数据出现了零次，实际上就意味着结点<strong>被删除</strong>或者结点
根本<strong>不存在</strong>。
没错，这个数组的一个重要作用就是用于标记<em>已删除</em>的结点。</p>
<p>下面这些数组有助于我们更方便地对树进行操作：</p>
<pre><code class="language-c">// 树的存储大小
int s[MAXN] = &#123;0&#125;;
// 树的逻辑上存在的结点大小，我将其视为树的实际大小（real size）
int rs[MAXN] = &#123;0&#125;;
// 树的带权大小，与`w`数组密切相关
int ws[MAXN] = &#123;0&#125;;
</code></pre>
<p>这些数组的意义其实是相同的：给出索引，得出以该结点为根的子树大小。
所谓树的大小，就是树所包含的结点数量，也是这些数组的差别所在：</p>
<ul>
<li><code>s</code>数组记录子树下所有结点的个数，包括逻辑删除的结点，
只有在重构时才不计删除结点。对于重复结点，逻辑上，该结点只出现了一次，
那么在存储结构上自然也只记录一次。</li>
<li><code>rs</code>数组记录子树的逻辑大小，与<code>s</code>数组不同，只记录逻辑上存在的结点数量，
也意味着已经删除的结点不计入，此外，重复结点只记录了一次。</li>
<li><code>ws</code>数组记录子树的带权大小，它与<code>rs</code>的差别只有：记录重复结点的重复次数，
也就是<code>w</code>数组中对应索引的值。</li>
</ul>
<p>在之后，这些数组代表的意思我会使用<strong>结点大小</strong>或者<strong>树大小</strong>代替，
一般来说都指的是<code>s</code>数组表示的大小。</p>
<h3 id="提供的树操作">提供的树操作</h3>
<p>由于我写替罪羊树的初衷只是了解它，因此只实现了树的插入、删除与查找。</p>
<p>首先让我们简单地梳理一下：</p>
<ol>
<li>替罪羊树处理不平衡结点的方式是重构。</li>
<li>不平衡结点的产生会在什么时候？
显然，在插入与删除这类会修改结点的操作可能导致不平衡结点的产生。</li>
<li>发生重构后，树的根可能会发生改变，如何更新这个根？
答案是在函数内更新，不需要通知调用方更新，因此需要指针。</li>
</ol>
<p>于是有这样的初步想法：调用方只需要关心调用结果，无需担心树是否需要重构，
重构在插入或删除时进行。</p>
<p>至于重构的条件，我们很快就会知道。</p>
<p>函数定义如下：</p>
<pre><code class="language-c">// 在树中查找值
// @param r 结点索引，表示在以此结点为根的树中找
// @param val 找的是这个值
// @return 这个值对应的结点索引是啥，如果为0表示不存在
int search_node(int r, int val);

// 将一个值插入树中
// @param *r 指针，内容是树的根，如果插入中发生了重构，则会更新根的值
// @param val 插入的值
void insert_node(int *r, int val);

// 将一个值从树中删除
// @note 如果值不存在，则不会发生任何事情
// @param *r 指针，内容同样是根的值，重构会更新这个值
// @param val 删除的值
void delete_node(int *r, int val);
</code></pre>
<h3 id="重构相关的函数">重构相关的函数</h3>
<p>我们首先定义重构的入口函数：</p>
<pre><code class="language-c">// 重构树
// @param *r 指针，重构的树以此为根
static void rebuild(int *r);
</code></pre>
<p>前面我们提到，重构的过程首先是将树进行中序展开，我们定义一个函数来实现这个操作：</p>
<pre><code class="language-c">// 序列化树
// @param r 以此为根的树
// @param *flat_tree 树的中序序列，序列化后的结果会保存在这里
// @param *tree_size 中序序列的长度
static void flat(int r, int *flat_tree, int *tree_size);
</code></pre>
<p>现在，我们需要一个函数，将得到的中序序列反序列化为树<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<pre><code class="language-c">// 生成树
// @param *flat_tree 树的中序序列
// @param l 反序列化起点，即左边界（left）
// @param r 反序列化终点，即右边界（right）
static int generate_tree(int *flat_tree, int l, int r);
</code></pre>
<p>最后，我们使用一个函数来判断是否进行重构：</p>
<pre><code class="language-c">// 是否应该重构
// @param r 以该结点为根
// @return ture表示需要重构，false表示不需要重构
static bool should_rebuild(int r);
</code></pre>
<h2 id="着手实现">着手实现</h2>
<h3 id="重构">重构</h3>
<p>在有了上面的思路后，就该开始实现定义的函数功能了。但是我们还遗留了一个问题：
<strong>重构的条件是什么？</strong></p>
<h4 id="重构的条件">重构的条件</h4>
<p>首先让我们回忆一下，一个平衡结点的理想状态应该是左右子树大小完全相同，
在替罪羊树中，这个条件放宽松一些：左右子树的结点数，也就是子树大小相差不大就行，
我们记较大的那个为$n$，此时，父结点的大小可以粗略认为是$m \coloneqq 2n + 1$。
显然有$0.5 \cdot m &gt; n$，我们将这个$0.5$记作$\alpha$，也就是之前定义的变量<code>alpha</code>。</p>
<p>上面提到的是树处于平衡状态的理想情况，然而实际上树不会一直保持平衡。
在严格的平衡二叉树中，一般通过旋转结点来保持平衡，
但在替罪羊树，只需要在子树的不平衡程度到了一定阈值时，将其重构即可，
而这个阈值与<code>alpha</code>相关。</p>
<p><code>alpha</code>本质上表达的意思是：最大的子树大小占根树大小的比例。
当树平衡时，左右子树的大小相差不大，因此最大子树大小占比约为$50\%$。
此时<code>alpha</code>取值<code>0.5</code>。
然而经验表明<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，在平衡二叉树中，这个比例在$70\% \sim 80\%$间，
平衡二叉树仍能保持其时间复杂度不变。</p>
<p>因此，在之前的定义中，<code>alpha</code>赋值为<code>0.75</code>。
而重构的条件则是<code>alpha * s[k] &lt; max(s[rt[k]], s[lt[k]])</code>。
在<a href="https://oi-wiki.org/ds/sgt/#%E8%BF%87%E7%A8%8B">OI Wiki的这篇文章中</a>，
还提到已删除结点过多也可能影响树的查找效率，
因此在删除结点过多时也重构：<code>rs[k] &lt; alpha * s[r]</code>。</p>
<h4 id="计算树的大小">计算树的大小</h4>
<p>在重构过程中需要使用到树的大小，因此先实现计算树大小的函数。</p>
<pre><code class="language-c">// 计算树的大小
// @param r 树的根结点索引
void gen_size(int r) &#123;
    if (!r)
        return;
    // 直接递归把子树大小计算出来
    gen_size(lt[r]);
    gen_size(rt[r]);
    // 现在子树的大小已经计算好了
    s[r] = s[lt[r]] + s[rt[r]] + 1;
    rs[r] = rs[lt[r]] + rs[rt[r]] + (w[r] &gt; 0 ? 1 : 0);
    ws[r] = ws[lt[r]] + ws[rt[r]] + w[r];
&#125;
</code></pre>
<p>值得注意的是，由于数组索引从<code>0</code>开始，于是有：
<code>s[0] == rs[0] == ws[0] == 0</code>，这样在叶子结点也可以保证计算正确。</p>
<h4 id="生成中序序列">生成中序序列</h4>
<p>生成中序序列其实就是将树中序遍历一次，非常容易实现，不过有个细节问题，
就是如何处理标记为<em>已删除</em>的结点，在我的实现里是将其忽略，
不过这会有一些问题，在最后面再详细讲讲吧。具体的实现如下：</p>
<pre><code class="language-c">void flat(int r, int *flat_tree, int *tree_size) &#123;
    if (!r)
        return;
    // 遍历左子树
    flat(lt[r], flat_tree, tree_size);
    // 访问根
    if (w[r] &gt; 0) &#123;
        // 进入中序序列
        flat_tree[*tree_size] = r;
        // 序列长度加一
        *tree_size += 1;
    &#125;
    // 遍历右子树
    flat(rt[r], flat_tree, tree_size);
&#125;
</code></pre>
<h4 id="反序列化">反序列化</h4>
<p>从中序序列反序列化出一棵树也比较简单：</p>
<pre><code class="language-c">int generate_tree(int *flat_tree, int l, int r) &#123;
    if (l &gt;= r || !flat_tree)
        return 0;
    // 中间的为根，需要注意，flat_tree中保存的才是结点索引
    int mid = (l + r) / 2;
    int k = flat_tree[mid];
    // 左子树
    lt[k] = generate_tree(flat_tree, l, mid);
    // 右子树
    rt[k] = generate_tree(flat_tree, mid + 1, r);
    // 返回根
    return k;
&#125;
</code></pre>
<h4 id="重构入口函数">重构入口函数</h4>
<p>入口函数只需要调用上面的两个函数即可完成树的重构：</p>
<pre><code class="language-c">// 我们需要更新的根，因此需要使用指针
void rebuild(int *r) &#123;
    // flat tree
    int ft[MAXN] = &#123;0&#125;;
    // tree size
    int ts = 0;
    // 序列化
    flat(*r, ft, &amp;ts);
    // 反序列化
    *r = generate_tree(ft, 0, ts);
    // 重新计算结点大小
    gen_size(*r);
&#125;
</code></pre>
<h4 id="判断是否需要重构">判断是否需要重构</h4>
<p>在之前我们已经分析过重构条件了，现在只要写出相应的代码就好了：</p>
<pre><code class="language-c">// 只是个选最大值的函数，其实可以不用
static max(a, b) &#123;
    return a &gt; b ? a : b;
&#125;

bool should_rebuild(int r) &#123;
    return alpha * s[r] &lt; (double)max(s[lt[r]], s[rt[r]]) // 树不平衡
        || (double)rs[r] &lt; alpha * s[r]; // 删除的结点过多
&#125;
</code></pre>
<h3 id="搜索">搜索</h3>
<p>和一般二叉树的搜索无异：</p>
<pre><code class="language-c">int search_node(int r, int val) &#123;
    if (!r)
        return 0;
    int child = 0;
    if (val &lt; v[r])
        // 小于结点值，在左子树搜
        child = lt[r];
    else if (val &gt; v[r])
        // 大于结点值，在右子树搜
        child = rt[t];
    else
        // 找到了值，但需要判断结点是否已经删除
        return w[r] ? r : 0;
    // 与当前结点值不同，则向子树递归搜索
    retrurn search_node(child, val);
&#125;
</code></pre>
<h3 id="插入">插入</h3>
<p>之前提到，相同值的结点在逻辑上只存在一个，并且使用<code>w</code>数组进行标识，
如果插入的值已经存在，那只需要更新<code>w</code>数组，若插入的值不存在，
那这个值一定会出现在叶子结点，于是我们有这两种情况：</p>
<ul>
<li>值在树中，更新<code>w</code>数组</li>
<li>值不再树中，新建结点：更新所有<strong>size数组</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，
更新<code>v</code>和<code>w</code>数组，结点计数<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>加一。</li>
</ul>
<pre><code class="language-c">void insert_node(int *r, int val) &#123;
    if (!r)
        return;
    if (!*r) &#123;
        // 到达叶子结点
        // 结点计数加一
        int k = ++count;
        // 这是我的实现存在的一个问题，需要判断一下
        if (k &gt; MAXN)
            return;
        w[k] = s[k] = rs[k] = ws[k] = 1;
        v[k] = val;
        // 更新结点
        *r = k;
    &#125; else &#123;
        // 现在还在树中
        if (val == v[*r])
            // 重复值
            w[*r]++;
        else if (val &lt; v[*r])
            insert_node(&amp;lt[*r], val);
        else
            insert_node(&amp;lt[*r], val);
    &#125;
    // 重新计算结点大小
    gen_size(*r);
    // 判断是否重构
    if (should_rebuild(*r))
        rebuild(r);
&#125;
</code></pre>
<h3 id="删除">删除</h3>
<p>由于我们使用逻辑删除，于是我们的删除函数只需要更新<code>w</code>数组即可，
需要注意的是不能直接将其赋值为0，因为可能有重复值。</p>
<pre><code class="language-c">void delete_node(int *r, int val) &#123;
    if (!r || !*r)
        return;
    if (val == v[*r]) &#123;
        // 存在，删除一个
        if (w[*r] &gt; 0) w[*r]--;
    &#125; else &#123;
        // 与结点值不同，在子树递归删除
        if (val &lt; v[*r])
            delete_node(&amp;lt[*r], val);
        else
            delete_node(&amp;rt[*r], val);
    &#125;
    // 更新结点大小
    gen_size(*r);
    // 检查是否重构
    if (should_rebuild(*r))
        rebuild(r);
&#125;
</code></pre>
<h2 id="一些问题">一些问题</h2>
<blockquote>
<p>这里的内容尚未完善…</p>
</blockquote>
<p>这个代码实现存在这么一个问题：结点被删除后，其索引不会被回收。
新的结点使用<code>count</code>获取结点索引，而<code>count</code>会不断增长，直到上限。
我想到的一个处理方式就是：在删除结点时，
将其与最新的<code>count</code>所代表的结点进行交换，并更新相应的数组以及其父节点的指向。</p>
<blockquote>
<p>不过还没实现这个想法…</p>
</blockquote>
<blockquote>
<p>alpha取值的由来还没去了解…</p>
</blockquote>
<blockquote>
<p>虽然还有那么多东西没写完，但还是发出来先，嘻嘻。</p>
</blockquote>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这个过程将使用递归方式，你问为什么不用循环？因为我不会… <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在参考的文章中有提到过，但没深入研究原因。=w= <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>就是<code>s[MAXN]</code>、<code>rs[MAXN]</code>以及<code>ws[MAXN]</code>这几个数组。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>在定义变量一节中，我们定义的<code>count</code>变量。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派上运行的服务</title>
    <url>/2024/07/10/services-running-on-my-raspberrypi/</url>
    <content><![CDATA[<p>记录一下在树莓派上运行的一些服务</p>
<span id="more"></span>
<h2 id="Nginx服务器">Nginx服务器</h2>
<p>我用域名<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>来访问树莓派上运行的所有服务，因此我搭建了Nginx，
用来反代树莓派上所有服务。</p>
<h2 id="Adguard-Home-DNS解析服务">Adguard Home DNS解析服务</h2>
<blockquote>
<p>Github仓库：<a href="https://github.com/AdguardTeam/AdguardHome">https://github.com/AdguardTeam/AdguardHome</a></p>
</blockquote>
<p>这个服务其实主要是用来解析树莓派的服务域名地址，广告过滤只是顺带的。
一开始是直接改hosts文件的，但这样要改所有会访问树莓派服务的设备的hosts，
这导致Android和ios都没办法使用树莓派服务。后来是改树莓派上的hosts文件，
并配合dnsmasq进行解析，但是由于dnsmasq没办法用网页管理，于是就弃用了。</p>
<h2 id="Aria2下载服务">Aria2下载服务</h2>
<blockquote>
<p>Aria2：<a href="https://aria2.github.io">https://aria2.github.io</a>
AriaNg: <a href="https://github.com/mayswind/AriaNg">https://github.com/mayswind/AriaNg</a></p>
</blockquote>
<p>Aria2本身只有命令行界面，AriaNg为其提供了web GUI，
部署在树莓派上就能够通过网页远程管理Aria2了。</p>
<p>Aria2用的频率其实不高，基本上只是用来下载一些需要在树莓派上使用的东西，
这样就不需要：开终端，wget一下，然后进入漫长的等待，最后关终端。</p>
<h2 id="Nextcloud私有云盘">Nextcloud私有云盘</h2>
<blockquote>
<p>官网：<a href="https://nextcloud.com">https://nextcloud.com</a></p>
</blockquote>
<p>云盘主要是用来自动上传文件，作为云端备份，比如这个博客的源文件就存在上面。
此外云盘有时会用Collabora office编辑一些文档，<s>问就是懒得重启到Windows编辑</s>。
但实际上用的很少，因为还在树莓派部署了Collabora office的内建服务器，
然而树莓派的性能有点不够用，<s>能用就行，要啥自行车</s>。</p>
<p>此外，云盘还被用来与Aria2配合，这样就能管理用Aria2下载的文件了。</p>
<h2 id="Syncthing文件同步服务">Syncthing文件同步服务</h2>
<blockquote>
<p>官网：<a href="https://syncthing.net">https://syncthing.net</a></p>
</blockquote>
<p>这个主要用来进行文件同步，但与Nextcloud有一些不同。</p>
<p>Nextcloud在Android上有个奇奇怪怪的问题。
在Linux上，我能将本地的不同位置的文件夹，比如<code>$HOME/Pictures/sync</code>、<code>$HOME/Videos/sync</code>
同步到云端的一个文件夹内，比如<code>sync/pictures</code>、<code>sync/videos</code>。
但在Android上，我只能将云端的文件夹<code>sync/pictures</code>、<code>sync/videos</code>，
按照云端的结构同步到本地，如<code>Android/media/.../sync/pictures</code>、
<code>Android/media/.../sync/videos</code>。</p>
<p>这很不合理，因为我在Android也有<code>Pictures/sync</code>与<code>Videos/sync</code>，
而Syncthing能够满足这个需求。</p>
<p><s>为什么会在树莓派上部署呢？因为树莓派只是作为syncthing的中介人…</s></p>
<h2 id="一些不常用的服务">一些不常用的服务</h2>
<h3 id="Homeassistant服务">Homeassistant服务</h3>
<blockquote>
<p>官网：<a href="https://www.home-assistant.io">https://www.home-assistant.io</a></p>
</blockquote>
<p>现已停用，原因：非常占内存，我的树莓派只有可怜的2G。</p>
<h3 id="Netdata性能监控">Netdata性能监控</h3>
<blockquote>
<p>官网：<a href="https://www.netdata.cloud">https://www.netdata.cloud</a></p>
</blockquote>
<p>这个服务只是一时兴起部署的，几乎很少使用。
<s>这个服务最大的共享就是让我发现Nextcloud的PHP后台真消耗性能，还有HASS</s></p>
<h3 id="Cups打印机服务">Cups打印机服务</h3>
<p>有个打印机，用cups在局域网内共享，没啥好说的。
<s>就是有时会找不到打印机，要重启一下服务</s></p>
<h3 id="Cockpit网页管理">Cockpit网页管理</h3>
<blockquote>
<p>官网：<a href="https://cockpit-project.org/">https://cockpit-project.org/</a></p>
</blockquote>
<p>这个是Redhat赞助的一个项目，可以在网页上管理树莓派，比如更新软件，启动服务等。
但我还是更喜欢在终端中进行这些操作，偶尔会在手机上使用一下。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>如aria2.my.domain，adguard.my.domain，地址解析用到了自建的DNS服务。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>aria2</tag>
        <tag>云盘</tag>
        <tag>文件同步</tag>
        <tag>远程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>smali 语法</title>
    <url>/2022/03/05/smali-language/</url>
    <content><![CDATA[<p>记录一下 smali 的基本语法，方便回顾</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>smali 语法与汇编语法挺相似的，
简要做一些笔记，仅仅只是一些简单的语法，
更多信息请查看文末的链接</p>
<h2 id="数据类型">数据类型</h2>
<p>以下是一些基本数据类型的表示</p>
<table>
<thead>
<tr>
<th style="text-align:left">smali</th>
<th style="text-align:left">Java</th>
<th style="text-align:left">smali</th>
<th style="text-align:left">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">int</td>
<td style="text-align:left">C</td>
<td style="text-align:left">char</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td style="text-align:left">short</td>
<td style="text-align:left">Z</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td style="text-align:left">long</td>
<td style="text-align:left">V</td>
<td style="text-align:left">void</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">float</td>
<td style="text-align:left">L</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">double</td>
<td style="text-align:left">B</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">数组</td>
<td style="text-align:left">[[</td>
<td style="text-align:left">二维数组</td>
</tr>
</tbody>
</table>
<p>例子</p>
<p><code>[I</code> 表示 int[] ，整型数组<br />
<code>Ljava/lang/String</code> 表示 String 类型，在 Java 中，
String 为 java.lang 包中的一个对象</p>
<h2 id="流程控制">流程控制</h2>
<h3 id="条件判断">条件判断</h3>
<p>语法如下：<br />
<code>if-&#123;cond&#125; v1, v0, :cond_0</code></p>
<p><code>&#123;cond&#125;</code> 是判断条件，在后面会列出<br />
<code>:cond_0</code> 是跳转的位置，类似与 C 语言中的 <code>goto</code> 标签</p>
<p>比如，当 v0 &gt;= v1 时，跳转到 <code>cond_0</code> 是这样写的：
<code>if-ge v0, v1, :cond_0</code></p>
<p>全部条件判断语句：<br />
<code>if-eq v0, v1</code>: <code>if (v0 == v1)</code>，eq 指 <strong>eq</strong>ual<br />
<code>if-ne v0, v1</code>: <code>if (v0 != v1)</code>，ne 指 <strong>n</strong>o <strong>e</strong>qula<br />
<code>if-ge v0, v1</code>: <code>if (v0 &gt;= v1)</code>，ge 指 <strong>g</strong>reater than or <strong>e</strong>qual<br />
<code>if-le v0, v1</code>: <code>if (v0 &lt;= v1)</code>，le 指 <strong>l</strong>ess than or <strong>e</strong>qual<br />
<code>if-gt v0, v1</code>: <code>if (v0 &gt; v1)</code>，gt 指 <strong>g</strong>reater <strong>t</strong>han<br />
<code>if-lt v0, v1</code>: <code>if (v0 &lt; v1)</code>，le 指 <strong>l</strong>ess <strong>t</strong>han</p>
<h3 id="循环">循环</h3>
<p>直接代码解释比较方便，例子来源参见文末链接1</p>
<pre><code class="language-java">public void smaliWhile() &#123;
    int a = 0;
    while(a &lt;= 3) &#123;
        a++;
    &#125;

    int b = 0;
    for(int i = 0;i&lt;3;i++)&#123;
        b++;
    &#125;

    int c = 0;
    do&#123;
        c++;
    &#125;while (c &lt;= 3);
&#125;
</code></pre>
<p>对应的 smali 语法</p>
<pre><code class="language-smali">.method public smaliWhile()V
    .locals 5

    .line 62
    // 4 字节常量，值为 0
    const/4 v0, 0x0

    // 赋值给 a
    move v1, v0

    .line 63
    .local v1, &quot;a&quot;:I
    // goto 标签
    :goto_0
    const/4 v2, 0x3

    // if (a &gt; 3), goto cond_0
    if-gt v1, v2, :cond_0

    .line 64
    // else v1 = v1 + 1
    add-int/lit8 v1, v1, 0x1

    goto :goto_0

    .line 68
    :cond_0
    const/4 v3, 0x0

    .line 69
    .local v3, &quot;b&quot;:I
    move v4, v3

    move v3, v0

    .local v3, &quot;i&quot;:I
    .local v4, &quot;b&quot;:I
    :goto_1
    if-ge v3, v2, :cond_1

    .line 70
    add-int/lit8 v4, v4, 0x1

    .line 69
    add-int/lit8 v3, v3, 0x1

    goto :goto_1

    .line 74
    .end local v3
    :cond_1
    nop

    .line 76
    .local v0, &quot;c&quot;:I
    :cond_2
    add-int/lit8 v0, v0, 0x1

    .line 77
    if-le v0, v2, :cond_2

    .line 78
    return-void
.end method
</code></pre>
<p>与汇编语法挺相似的，不多解释<br />
<s>其实是懒得写笔记</s></p>
<h2 id="函数定义">函数定义</h2>
<p>一般定义长这个样子:
<code>funcName (paraType1paraType2...)returnType</code></p>
<ul>
<li><code>funcName</code> 表示函数名</li>
<li><code>paraType1</code> 和 <code>paraType2</code> 表示传入参数的类型，他们之间<strong>没有</strong>空格</li>
<li><code>returnType</code> 表示返回值类型</li>
</ul>
<p>例子</p>
<p><code>foo (IF)Z</code> 是 <code>boolean foo (int, float)</code></p>
<p><code>bar([ILjava/lang/String)Z</code> 是 <code>boolean bar(int[], String)</code></p>
<h2 id="内部类">内部类</h2>
<p>smali 使用 <code>$</code> 表示内部类，像这样子
<code>LpackageName/objectName$subObjName</code></p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://forum.xda-developers.com/t/guide-smali-coding-guide-for-beginners.2193735">Smali coding guide for beginners</a></li>
<li><a href="https://programmer.help/blogs/smali-introduction-manual.html">Smali Introduction Manual</a></li>
</ol>
]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>smali</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>/2023/07/19/smart-questions/</url>
    <content><![CDATA[<!-- more -->
]]></content>
  </entry>
  <entry>
    <title>Github Page时间测试</title>
    <url>/2023/01/01/time-test/</url>
    <content><![CDATA[<p>时间格式测试</p>
<span id="more"></span>
<p>发现Github Page上的日期比实际的日期少一天。</p>
<p>似乎是时区问题？没有验证。</p>
]]></content>
  </entry>
  <entry>
    <title>欠拟合与过拟合</title>
    <url>/2021/10/26/underfitting-and-overfitting/</url>
    <content><![CDATA[<p>机器学习中遭遇的问题</p>
<span id="more"></span>
<h2 id="欠拟合与过拟合">欠拟合与过拟合</h2>
<h3 id="欠拟合">欠拟合</h3>
<p>欠拟合指学习得出的模型并不能很好地模拟出数据的分布规律</p>
<p>问题的原因在于训练时，用于训练的模型不是很好，
当尝试用低阶模型去拟合高阶模型时，就会出现欠拟合的情况<br />
比如<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<p><img src="Figure_1.svg" alt="&quot;Figure_1&quot;" title="Figure 1" loading="lazy" /></p>
<h3 id="过拟合">过拟合</h3>
<p>过拟合指的是通过学习得出的模型，能很好地描述训练集中“特征与标签”的关系，
但是进行预测的结果很差，或者模型本身过于负责，并不适合实际应用</p>
<p>也就是说，过拟合就是对训练集中的数据的拟合效果好，但实际用的时候效果并不理想<br />
下面是一个不太明显的例子，但我想应该足够体现出过拟合的概念了<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<p><img src="Figure_2.svg" alt="&quot;Figure_2&quot;" title="Figure 2" loading="lazy" /></p>
<p>或许加上原数据之间的连线更能体现：</p>
<p><img src="Figure_3.svg" alt="&quot;Figure_3&quot;" title="Figure 3" loading="lazy" /></p>
<h2 id="解决方法">解决方法</h2>
<p>一个解决方法是使用 <strong>非参数学习算法</strong> ，
<strong>局部加权回归算法</strong> 则属于这一类算法<br />
详情参考 <a href="/2021/10/30/locally-weighted-regression/" title="局部加权回归">这篇文章</a></p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>图中数据为随机生成，使用解析式法得出结果 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>同上 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 简单笔记</title>
    <url>/2021/02/19/vim-simple-note/</url>
    <content><![CDATA[<p>总结自 vim 使用向导程序 <code>vimtutor</code></p>
<span id="more"></span>
<h3 id="前言">前言</h3>
<ol>
<li>
<p>vim 光标为方块光标，简称“光标”，<br />
本文将光标方块覆盖字符时的位置称为“光标当前位置”<br />
此时字符称为“当前字符”<br />
光标当前位置的左边称为“光标前”，右边则称为“光标后”</p>
</li>
<li>
<p>vim 中操作按键区分大小写</p>
</li>
<li>
<p>vim 可分为三种模式</p>
<ul>
<li>正常模式，启动时进入正常模式，在任何模式按 <code>Esc</code> 可回到正常模式</li>
<li>编辑模式，正常模式下按 <code>a/A</code>、<code>i/I</code>、<code>o/O</code> 可进入编辑模式</li>
<li>命令行模式，正常模式下按 <code>:</code> 可进入命令行模式</li>
</ul>
<p>正常模式下可通过单个按键的组合进行操作，在本文中称为命令。
命令行模式下可运行命令行进行一些更复杂的操作，比如运行外部程序。</p>
</li>
</ol>
<h3 id="简单介绍">简单介绍</h3>
<h4 id="移动光标">移动光标</h4>
<p>使用 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 移动光标</p>
<ul>
<li><code>h</code> 位于左边，控制光标左移</li>
<li><code>l</code> 位于右边，控制光标右移</li>
<li><code>j</code> 看起来像一个向下的箭头，<s>神奇的脑洞</s></li>
<li><code>l</code> 就剩下向上的方向可以给它了</li>
</ul>
<h4 id="文本编辑">文本编辑</h4>
<ol>
<li>
<p><strong>添加文本</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>a</code></td>
<td style="text-align:left">在光标后开始输入</td>
</tr>
<tr>
<td style="text-align:left"><code>A</code></td>
<td style="text-align:left">在行尾开始输入</td>
</tr>
<tr>
<td style="text-align:left"><code>i</code></td>
<td style="text-align:left">在光标前开始输入</td>
</tr>
<tr>
<td style="text-align:left"><code>I</code></td>
<td style="text-align:left">在行首开始输入</td>
</tr>
<tr>
<td style="text-align:left"><code>o</code></td>
<td style="text-align:left">在光标下的新的空行开始输入</td>
</tr>
<tr>
<td style="text-align:left"><code>O</code></td>
<td style="text-align:left">在光标上的新的空行开始输入</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>删除文本</strong></p>
<ol>
<li>正常模式下可进行简单的删除操作<br />
例如，按 <code>x</code> 可删除当前字符<br />
还有一些高级点的删除操作，使用了正常模式下的命令操作</li>
<li>编辑模式下就直接编辑删除就行</li>
</ol>
</li>
</ol>
<h4 id="保存与退出">保存与退出</h4>
<ul>
<li><code>:w</code>：保存文件</li>
<li><code>:q</code>：退出</li>
<li><code>:wq</code>：保存文件并退出。</li>
<li><code>:q!</code>：强制退出，不保存更改</li>
</ul>
<h4 id="查看帮助">查看帮助</h4>
<p>遇到不会的就看帮助文档<br />
<s>虽然全英</s></p>
<ul>
<li><code>:help</code>：查看帮助</li>
<li><code>&lt;F1&gt;</code>：查看帮助</li>
<li><code>:help [command]</code>：可显示相关命令帮助</li>
</ul>
<h3 id="普通模式下的命令操作">普通模式下的命令操作</h3>
<h4 id="常用按键命令">常用按键命令</h4>
<ol>
<li>
<p><strong>删除</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x</code></td>
<td style="text-align:left">删除当前字符</td>
</tr>
<tr>
<td style="text-align:left"><code>d</code></td>
<td style="text-align:left">删除命令，需要配合其他按键使用</td>
</tr>
<tr>
<td style="text-align:left"><code>dd</code></td>
<td style="text-align:left">删除当前行</td>
</tr>
</tbody>
</table>
<p>注：删除的文本会暂时存入缓存</p>
</li>
<li>
<p><strong>高级移动</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>w</code></td>
<td style="text-align:left">将光标从当前位置移动到下一个单词前</td>
</tr>
<tr>
<td style="text-align:left"><code>e</code></td>
<td style="text-align:left">从当前位置移动到单词结尾</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">从当前位置移动到行尾</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>编辑</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>r</code></td>
<td style="text-align:left">替换当前字符</td>
</tr>
<tr>
<td style="text-align:left"><code>R</code></td>
<td style="text-align:left">可连续替换多个字符</td>
</tr>
<tr>
<td style="text-align:left"><code>c</code></td>
<td style="text-align:left">替换一段文本，需配合其他按键</td>
</tr>
<tr>
<td style="text-align:left"><code>:s</code></td>
<td style="text-align:left">替换匹配的字符串，用法见下方介绍</td>
</tr>
<tr>
<td style="text-align:left"><code>p</code></td>
<td style="text-align:left">粘贴缓存中的文本</td>
</tr>
<tr>
<td style="text-align:left"><code>u</code></td>
<td style="text-align:left">撤销上一个命令操作</td>
</tr>
<tr>
<td style="text-align:left"><code>U</code></td>
<td style="text-align:left">撤销对一整行的更改</td>
</tr>
<tr>
<td style="text-align:left"><code>v</code></td>
<td style="text-align:left">进入可视模式进行文本选择</td>
</tr>
<tr>
<td style="text-align:left"><code>y</code></td>
<td style="text-align:left">复制选择的文本</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>查找</strong>
查找命令比较复杂，往下看详细点的介绍</p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">往后进行字符串查找</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">往前进行字符串查找</td>
</tr>
<tr>
<td style="text-align:left"><code>n</code></td>
<td style="text-align:left">同上一次查找</td>
</tr>
<tr>
<td style="text-align:left"><code>N</code></td>
<td style="text-align:left">反向查找上一次查找的字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">进行匹配括号查找</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>查看与跳转</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ctrl-G</code></td>
<td style="text-align:left">显示光标位置以及文件状态信息</td>
</tr>
<tr>
<td style="text-align:left"><code>G</code></td>
<td style="text-align:left">跳转到文件末尾，或指定行</td>
</tr>
<tr>
<td style="text-align:left"><code>gg</code></td>
<td style="text-align:left">跳转至文件开头</td>
</tr>
<tr>
<td style="text-align:left"><code>ctrl-O</code></td>
<td style="text-align:left">在查找后，跳转到较先(旧)查找到的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>ctrl-I</code></td>
<td style="text-align:left">在查找后，跳转到较晚(新)查找到的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>ctrl-w</code>x2</td>
<td style="text-align:left">可切换窗口</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="删除类命令">删除类命令</h4>
<ol>
<li><strong><code>d</code> 的使用</strong><br />
<strong>方法：<code>d+[num]+motion</code></strong>
<ul>
<li><code>d</code>: 删除操作符</li>
<li><code>[num]</code>: 可选，操作重复次数</li>
<li><code>motion</code>：操作对象，可以为<code>w</code>，<code>e</code>，<code>$</code></li>
</ul>
</li>
</ol>
<p>示例：</p>
<ul>
<li><code>dw</code>：将光标位置置于单词第一个字母，可删除一个单词</li>
</ul>
<h4 id="替换类命令">替换类命令</h4>
<ol>
<li>
<p><strong><code>c</code> 的使用</strong><br />
<strong>方法：<code>c+[num]+motion</code></strong></p>
<ul>
<li><code>c</code>: 替换操作符</li>
<li><code>[num]</code>: 可选，操作重复次数</li>
<li><code>motion</code>：操作对象，可以为<code>w</code>，<code>e</code>，<code>$</code>
注：<code>c</code> 命令可以理解为：使用 <code>d</code> 删除了要替换的文本，并自动进入编辑模式</li>
</ul>
</li>
<li>
<p><strong><code>:s</code> 的使用</strong><br />
<strong>方法：<code>:s/old/new[/g[c]]</code></strong><br />
上例中，会将光标所在行的第一个匹配到的<code>old</code> 字符串替换为 <code>new</code><br />
选项 <code>g</code> 会使此行中的所有 <code>old</code> 替换为 <code>new</code><br />
选项 <code>c</code> 会在替换前要求确认</p>
</li>
</ol>
<h4 id="搜索类命令">搜索类命令</h4>
<ol>
<li>
<p><strong><code>/</code> 的使用</strong><br />
<strong>方法：<code>/str</code></strong><br />
输入 <code>/</code> 后接字符串，将在光标处开始往后查询匹配的字符串</p>
</li>
<li>
<p><strong><code>？</code> 的使用</strong><br />
<strong>方法：<code>？str</code></strong><br />
与 <code>/</code> 相似，但与 <code>/</code> 的查找方向相反，</p>
</li>
<li>
<p><strong><code>n</code> 与 <code>N</code> 的使用</strong><br />
输入 <code>n</code> 执行上一次查找<br />
输入 <code>N</code> 往相反方向查找与上一次查找相同的字符串</p>
</li>
<li>
<p><strong><code>%</code> 的使用</strong><br />
将光标移到括号上，按下 <code>%</code> 将跳转至匹配的括号<br />
注：没有移到括号上也可以查找，有一定规则，懒得描述，去试一试就清楚了</p>
</li>
</ol>
<h4 id="跳转类命令">跳转类命令</h4>
<ol>
<li><strong><code>G</code> 的使用</strong><br />
<strong>方法：<code>[num]+G</code></strong>
<ul>
<li><code>[num]</code>：要跳转至的行数</li>
</ul>
</li>
</ol>
<h3 id="命令行模式简单使用">命令行模式简单使用</h3>
<p>在正常模式下输入 <code>:</code> 即可进入命令行模式</p>
<h4 id="对vim进行设置">对vim进行设置</h4>
<p>使用<code>:set [setting]</code>，可设置相关项，一些有用的选项如下</p>
<ul>
<li><code>ic</code>：查找时忽略字母大小写</li>
<li><code>is</code>：查找短语时显示部分匹配</li>
<li><code>hls</code>：高亮显示所有匹配部分
在选项前加上 <code>no</code> 可关闭选项，如 <code>noic</code> 可关闭忽略大小写</li>
</ul>
<h4 id="运行外部命令">运行外部命令</h4>
<p>在正常模式下输入 <code>:!</code>，紧接着输入外部命令即可<br />
例如：<code>:!ls</code> 将列出目录下的文件</p>
<h4 id="切换至外部-shell">切换至外部 shell</h4>
<p>使用<code>：shell</code>可以切换到命令行窗口<br />
在命令行窗口退出会回到 vim</p>
<h4 id="多窗口">多窗口</h4>
<ol>
<li>
<p>打开多窗口<br />
横行切分窗口</p>
<ul>
<li><code>:new [file]</code>：<code>[file]</code> 是打开的文件，若不是存在的文件则在保存后会创建文件</li>
<li><code>:split [file]</code>：同上，可简写为 <code>:sp [file]</code></li>
</ul>
<p>纵向切分窗口</p>
<ul>
<li><code>:vsplit [file]</code>：同上，窗口切分方式不同</li>
</ul>
</li>
<li>
<p>关闭多窗口<br />
可使用普通窗口的保存与退出的方式，或者以下命令</p>
<ul>
<li><code>:close</code>：关闭窗口，但文件存在缓存中，使用 <code>:q!</code> 才算真正退出</li>
<li><code>:tabc</code>：关闭当前窗口</li>
<li><code>:tabo</code>：关闭所有窗口</li>
</ul>
</li>
<li>
<p>切换窗口<br />
首先按下 <code>ctrl-w</code>，后按：</p>
<ul>
<li><code>j</code>：切换到下一个窗口</li>
<li><code>k</code>：切换到上一个窗口</li>
<li><code>ctrl-w</code>：依次切换</li>
</ul>
</li>
<li>
<p>更改大小</p>
<ul>
<li>横向调整
<ul>
<li><code>ctrl-w +</code>：扩大窗口</li>
<li><code>ctrl-w -</code>：减小窗口</li>
<li><code>:resize [num]</code>：将窗口更改为 <code>[num]</code> 行</li>
<li><code>:resize+[num]</code>：将窗口大小增加 <code>[num]</code> 行</li>
<li><code>:resize-[num]</code>：将窗口大小减少 <code>[num]</code> 行</li>
</ul>
</li>
<li>纵向调整
<ul>
<li><code>:vertical resize [num]</code>：将窗口更改为 <code>[num]</code> 列</li>
<li><code>:vertical resize+[num]</code>：将窗口大小增加 <code>[num]</code> 列</li>
<li><code>:vertical resize-[num]</code>：将窗口大小减少 <code>[num]</code> 列</li>
</ul>
</li>
</ul>
</li>
<li>
<p>窗口重命名</p>
<ul>
<li><code>:f [newname]</code>：<code>[newname]</code> 为窗口新名字</li>
</ul>
</li>
<li>
<p>打开多文件<br />
在shell中打开文件时，使用 <code>vim a b c</code></p>
<ul>
<li><code>:n</code>：跳至下一文件</li>
<li><code>:n c</code>：跳至 <code>文件c</code></li>
<li><code>:e#</code>：返回上一个编辑的文件</li>
</ul>
</li>
<li>
<p>文件浏览</p>
<ul>
<li><code>:Ex</code>：开启目录浏览器</li>
<li><code>:ls</code>：显示当前缓存情况</li>
</ul>
</li>
<li>
<p>临时切换到shell</p>
<ul>
<li><code>:shell</code>：切换到shell，退出shell即可回到vim</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用最小二乘法</title>
    <url>/2021/11/04/why-use-least-squares/</url>
    <content><![CDATA[<p>解释为什么最小二乘法能减小误差</p>
<span id="more"></span>
<h2 id="了解一下误差">了解一下误差</h2>
<p>假设预测结果与实际结果存在误差，即</p>
<p>$$
\begin{equation}
y^{(i)} = \theta^{T} x^{(i)} + \varepsilon^{(i)}
\end{equation}
$$</p>
<p>其中$ \varepsilon^{(i)} $就称为误差</p>
<p>如果$ \varepsilon^{(i)} $存在某种分布，
于是我们可以假设这个分布为<strong>高斯分布</strong>，或者说是<strong>正态分布</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><br />
即：</p>
<p>$$
\varepsilon^{(i)} \sim N(0, \sigma^{2})
$$</p>
<p>于是有：</p>
<p>$$
\begin{equation}
P(\varepsilon^{(i)}) = \frac{1}{\sqrt{2 \pi} \sigma}
\exp{(- \frac{ ( \varepsilon^{(i)} )^{2} }{2 \sigma^{2} })}
\end{equation}
$$</p>
<h2 id="最大化预测期望等价于最小化误差">最大化预测期望等价于最小化误差</h2>
<p>由$ (1) $和$ (2) $得<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<p>$$
\begin{equation}
P(y^{i} \mid x^{i} ; \theta)
= \frac{1}{\sqrt{2 \pi} \sigma}
\exp{(- \frac{ ( y^{(i)} - \theta^{T} x^{(i)} )^{2} }{2 \sigma^{2} })}
\end{equation}
$$</p>
<p>于是得到：
$
(y^{i} \mid x^{i} ; \theta) \sim N(\theta^{T} x^{(i)}, \sigma^{2})
$</p>
<p>我们又假设，$ \varepsilon^{i} $之间相互独立，且具有相同的分布，
然后我们使用<strong>极大似然估计</strong>将$ (3) $最大化<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>设</p>
<p>$$
\begin{equation}
\begin{split}
L(\theta)
&amp; = P(Y \mid X ; \theta) \\
&amp; = \prod_{i=1}^{m} P(y^{i} \mid x^{i} ; \theta) \\
&amp; = \prod_{i=1}^{m} \frac{1}{\sqrt{2 \pi} \sigma}
\exp{(- \frac{ ( y^{(i)} - \theta^{T} x^{(i)} )^{2} }{2 \sigma^{2} })}
\end{split}
\end{equation}
$$</p>
<p>那么</p>
<p>$$
\begin{equation}
\begin{split}
l(\theta)
&amp; = \log{L(\theta)} \\
&amp; = \sum_{i=1}^{m} \log{ \frac{1}{ \sqrt{2 \pi} \sigma }
\exp{( - \frac{( y^{(i)} - \theta^{T} x^{(i)} )^{2}}{ 2 \sigma^{2} } )}} \\
&amp; = m \log{\frac{1}{\sqrt{2 \pi} \sigma}} + \sum_{i=1}^{m} -( \frac{y^{(i)}
- \theta^{T} x^{(i)}}{2 \sigma^{2}} )
\end{split}
\end{equation}
$$</p>
<p>由于$ \sigma^{2} &gt; 0 $恒成立，
故最大化$ l(\theta) $等价于最小化$ \sum_{i=1}^{m} \frac{y^{(i)} - \theta^{T} x^{(i)}}{2} $</p>
<p>这也就是 <a href="/2021/09/11/linear-regression/" title="线性回归">线性回归</a> 一文中提到的<strong>cost function</strong></p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>根据<strong>中心极限定理</strong>可知，误差的分布在大多数情况下都成正态分布，这是一个合理的假设 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>这是<strong>极大似然估计</strong>里的表示方式，$ \theta $表示一个参数，
随后求得$ \theta $使$ P(y^{i} \mid x^{i}) $最大 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>应当注意：$ (3) $中自然常数的指数为负数 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小二乘法</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
</search>
